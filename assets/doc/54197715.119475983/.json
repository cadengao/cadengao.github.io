{
  "UUID": "54197715.119475983",
  "id": 0,
  "type": null,
  "format": null,
  "title": "C#-异步编程【Area】",
  "tags": null,
  "slug": null,
  "Tags": null,
  "description": null,
  "cover": null,
  "book_id": 0,
  "BookName": null,
  "public": 0,
  "word_count": 0,
  "created_at": "0001-01-01T00:00:00",
  "updated_at": "0001-01-01T00:00:00",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h1 id=\"h6mi6\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">什么是异步</span></strong></h1><p id=\"u2c9cfd8d\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">同步和异步主要用于修饰方法。当一个方法被调用时，调用者需要等待该方法执行完毕并返回才能继续执行，我们称这个方法是同步方法；当一个方法被调用时</span><strong><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">立即返回</span></strong><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">，并获取一个线程执行该方法内部的业务，调用者不用等待该方法执行完毕，我们称这个方法为异步方法。</span></p><div data-type=\"color1\" class=\"ne-alert\"><p id=\"uac877551\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 14px\">Thread &lt; ThreadPoll &lt; Task &lt; Async await</span></strong><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"><br /></span><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注:</span></p><ol class=\"ne-ol\"><li id=\"u05a10ecd\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">后者性能高于前者</span></li><li id=\"udb73b451\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">上述情况只在频繁使用线程的情况下适用</span></li></ol></div><h1 id=\"ByNSH\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">Th</span><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">read</span></strong><span class=\"ne-text\">介绍</span></h1><h2 id=\"Rvuuv\"><span class=\"ne-text\">Thread创建的方法</span></h2><pre data-language=\"csharp\" id=\"x7cE5\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    //创建线程，并指定线程开始执行时要调用的方法。也可以指定一个委托或者Lambda表达式\n    Thread thread = new Thread(Function);\n    //指定线程为后台线程，如果不指定为前台线程。\n    thread.IsBackground = true;\n    //指定线程优先级别\n    /*\n     * 线程在C#中有5个优先级：（从低到高）Lowest -&gt; BelowNormal -&gt; Normal -&gt;AboveNormal -&gt; Highest\n     * 默认状态下是：Normal。在单核CPU中效果明显，多核CPU中效果不太明显，如果希望线程尽快执行，可以把\n     * 优先级设定高一点。\n     */\n    thread.Priority = ThreadPriority.AboveNormal;\n    //启动线程。（实际操作中，并不是立即启动，而是告诉CPU，这个线程准备好了，具体什么时候启动由CPU统一调度）\n    thread.Start();\n    Console.ReadKey();\n}\n\nprivate static void Function()\n{\n    while(true)\n    {\n        Console.WriteLine(DateTime.Now.ToString());\n        Thread.Sleep(1000);\n    }      \n}</code></pre><p id=\"uf323f98c\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/2.png\" width=\"411\" id=\"u6b3674c1\" class=\"ne-image\"></p><h2 id=\"yV5eH\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">Thread阻塞线程的方法</span></strong></h2><p id=\"u5ceda315\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">用 </span><code class=\"ne-code\"><strong><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">thread.Join()</span></strong></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">方法即可阻塞主线程。看一个例子：</span></p><pre data-language=\"csharp\" id=\"TaFBQ\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Thread th1 = new Thread(() =&gt; {\n        Thread.Sleep(500);\n        Console.WriteLine(&quot;线程1执行完毕！&quot;);\n    });\n    th1.Start();\n    Thread th2 = new Thread(() =&gt; {\n        Thread.Sleep(1000);\n        Console.WriteLine(&quot;线程2执行完毕！&quot;);\n    });\n    th2.Start();\n    //阻塞主线程\n    th1.Join();\n    th2.Join();\n    Console.WriteLine(&quot;主线程执行完毕！&quot;);\n    Console.ReadKey();\n}</code></pre><p id=\"uaaaeed84\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">如果注释掉两个Join，执行结果是：先打印【主线程执行完毕】，而添加两个Join方法后执行结果如下，实现了线程阻塞：</span></p><p id=\"u461579f9\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/4.png\" width=\"295\" id=\"u05f092a6\" class=\"ne-image\"></p><p id=\"ubbbed8e4\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> Thread的Join方法可以阻塞调用线程，但是有一些弊端：①如果我们要实现很多线程的阻塞时，每个线程都要调用一次Join方法；②如果我们想让所有的线程执行完毕(或者任一线程执行完毕)时，立即解除阻塞，使用Join方法不容易实现。</span></p><p id=\"u9eb10df0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\">Thread中Start方法的流程图</span></p><p id=\"u56321f29\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/1.png\" width=\"2748\" id=\"M2Eh7\" class=\"ne-image\"></p><h2 id=\"jEnYr\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">Thread取消任务</span><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">的方法</span></strong></h2><p id=\"u34752fa5\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">一般流程是：设置一个变量来控制任务是否停止，如设置一个变量isStop，然后线程轮询查看isStop，如果isStop为true就停止，代码如下：</span></p><pre data-language=\"csharp\" id=\"ehIDW\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    bool isStop = false;\n    int index = 0;\n    //开启一个线程执行任务\n    Thread th1 = new Thread(() =&gt;\n      {\n          while (!isStop)\n          {\n              Thread.Sleep(1000);\n              Console.WriteLine($&quot;第{++index}次执行，线程运行中...&quot;);\n          }\n      });\n    th1.Start();\n    //五秒后取消任务执行\n    Thread.Sleep(5000);\n    isStop = true;\n    Console.ReadKey();\n}</code></pre><h2 id=\"KkikX\"><span class=\"ne-text\">警惕两点：</span></h2><ol class=\"ne-ol\"><li id=\"uaf5fb022\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F\">线程不会立即执行</span></strong></li></ol><div class=\"ne-quote\"><p id=\"u4be52d66\" class=\"ne-p\"><span class=\"ne-text\">现在的大多数系统不是一个实时的操作系统，Window也是如此。所以不要奢望线程能够立即启动。Window内部会实现特殊的算法进行线程之间的调度。在某个时刻它会决定当前运行那个线程。这反映到最底层就是某个线程分配到一定的CPU时间，可以用来执行一小段工作（由于被分配的CPU时间很短，所以操作系统中运行者上千个线程，我们也会觉得这些应用程序也是在同时执行的）。Window会选择适当的时间根据自己的算法决定下一段的CPU时间如何调度。</span></p></div><ol start=\"2\" class=\"ne-ol\"><li id=\"u597f7ad3\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">线程终止涉及两个问题：</span></strong></li></ol><div class=\"ne-quote\"><ul class=\"ne-ul\"><li id=\"u053bc8eb\" data-lake-index-type=\"0\"><span class=\"ne-text\">正如线程不能立即启动一样，线程不是说停就停。无论采用什么样的方式通知线程停止，线程都会执行完毕后，在合适的情况下停止。 thread.Abort()方法，如果线程正在执行的是一段非托管代码，那么，CLR 就不会抛出 ThreadAbortException,只有当代码继续回到 CLR 时，才会引发ThreadAbortException。</span></li><li id=\"u2ca57b5e\" data-lake-index-type=\"0\"><span class=\"ne-text\">要正确停止线程，不在于调用者采用了什么行为，而是更多依赖工作线程是否主动响应调用者的停止请求，大体的机制是，如果线程需要被停止，那么线程本身就应该负责给调用者开放这样的接口，Canclen。线程在工作的同时，还要以某种频率检查Canclen标识。若检测到Canclen，线程才会停止，对于 ThreadPool（线程池）同样。</span></li></ul></div><h1 id=\"NBtf8\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">Th</span><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">readPool介绍</span></strong></h1><p id=\"ub24705de\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">ThreadPool中有若干数量的线程，如果有任务需要处理时，会从线程池中获取一个空闲的线程来执行任务，任务执行完毕后线程不会销毁，而是被线程池回收以供后续任务使用。当线程池中所有的线程都在忙碌时，又有新任务要处理时，线程池才会新建一个线程来处理该任务，如果线程数量达到设置的最大值，任务会排队，等待其他任务释放线程后再执行。线程池能减少线程的创建，节省开销，看一个ThreadPool的例子吧。</span></p><pre data-language=\"csharp\" id=\"wagqN\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    for (int i = 1; i &lt;=10; i++)\n    {\n        //ThreadPool执行任务\n        ThreadPool.QueueUserWorkItem(new WaitCallback((obj) =&gt; {\n            Console.WriteLine($&quot;第{obj}个执行任务&quot;);\n        }),i);\n    }\n    Console.ReadKey();\n}</code></pre><p id=\"u8d83b44e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">上边的代码通过ThreadPool执行了10个任务，执行结果为：</span></p><p id=\"u3f5876a2\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/6.png\" width=\"338\" id=\"u49c53863\" class=\"ne-image\"></p><div class=\"ne-quote\"><p id=\"u31277d0e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">ThreadPool相对于Thread来说可以减少线程的创建，有效减小系统开销；但是ThreadPool不能控制线程的执行顺序，我们也不能获取线程池内线程取消/异常/完成的通知，即我们不能有效监控和控制线程池中的线程。</span></p></div><h1 id=\"wVYMB\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">Task介绍</span></strong></h1><p id=\"u1864bcc0\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Task是在ThreadPool的基础上推出的，我们知道了ThreadPool的弊端：</span><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 14px\">我们不能控制线程池中线程的执行顺序，也不能获取线程池内线程取消/异常/完成的通知</span></strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 14px\">。</span><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">net4.0在ThreadPool的基础上推出了Task，Task拥有线程池的优点，同时也解决了使用线程池不易控制的弊端。</span></p><h2 id=\"phWIp\"><span class=\"ne-text\">Task创建和运行</span></h2><p id=\"ue3e7429d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">首先看一下怎么去创建并运行一个Task，Task的创建和执行方式有如下三种：</span></p><pre data-language=\"csharp\" id=\"DSRj6\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    //1.new方式实例化一个Task，需要通过Start方法启动\n    Task task = new Task(() =&gt;\n    {\n        Thread.Sleep(100);\n        Console.WriteLine($&quot;hello, task1的线程ID为{Thread.CurrentThread.ManagedThreadId}&quot;);\n    });\n    task.Start();\n    //2.Task.Factory.StartNew(Action action)创建和启动一个Task\n    Task task2 = Task.Factory.StartNew(() =&gt;\n      {\n          Thread.Sleep(100);\n          Console.WriteLine($&quot;hello, task2的线程ID为{ Thread.CurrentThread.ManagedThreadId}&quot;);\n      });\n    //3.Task.Run(Action action)将任务放在线程池队列，返回并启动一个Task\n    Task task3 = Task.Run(() =&gt;\n      {\n          Thread.Sleep(100);\n          Console.WriteLine($&quot;hello, task3的线程ID为{ Thread.CurrentThread.ManagedThreadId}&quot;);\n      });\n    Console.WriteLine(&quot;执行主线程！&quot;);\n    Console.ReadKey();\n}</code></pre><p id=\"u3a144e85\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">执行结果如下：</span></p><p id=\"u579fd5de\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/7.png\" width=\"295\" id=\"u1828bea0\" class=\"ne-image\"></p><p id=\"ua7b4e4a5\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">我们看到先打印&quot;执行主线程&quot;，然后再打印各个任务，说明了Task不会阻塞主线程。上边的例子Task都没有返回值，我们也可以创建有返回值的 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Task&lt;TResult&gt;</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">，用法和没有返回值的基本一致,我们简单修改一下上边的例子，代码如下：</span></p><pre data-language=\"csharp\" id=\"IAdqB\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    ////1.new方式实例化一个Task，需要通过Start方法启动\n    Task&lt;string&gt; task = new Task&lt;string&gt;(() =&gt;\n    {\n        return $&quot;hello, task1的ID为{Thread.CurrentThread.ManagedThreadId}&quot;;\n    });\n    task.Start();\n    ////2.Task.Factory.StartNew(Func func)创建和启动一个Task\n   Task&lt;string&gt; task2 =Task.Factory.StartNew&lt;string&gt;(() =&gt;\n    {\n        return $&quot;hello, task2的ID为{ Thread.CurrentThread.ManagedThreadId}&quot;;\n    });\n    ////3.Task.Run(Func func)将任务放在线程池队列，返回并启动一个Task\n   Task&lt;string&gt; task3= Task.Run&lt;string&gt;(() =&gt;\n    {\n        return $&quot;hello, task3的ID为{ Thread.CurrentThread.ManagedThreadId}&quot;;\n    });\n    Console.WriteLine(&quot;执行主线程！&quot;);\n    Console.WriteLine(task.Result);\n    Console.WriteLine(task2.Result);\n    Console.WriteLine(task3.Result);\n    Console.ReadKey();\n}</code></pre><p id=\"u3d681683\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注意task.Resut获取结果时会阻塞线程，即如果task没有执行完成，会等待task执行完成获取到Result，然后再执行后边的代码，程序运行结果如下：</span></p><p id=\"u4180ce76\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/5.png\" width=\"294\" id=\"u406147e6\" class=\"ne-image\"></p><p id=\"u3b79bb90\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">上边的所有例子中Task的执行都是异步的，不会阻塞主线程。有些场景下我们想让Task同步执行怎么办呢？Task提供了 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">task.RunSynchronously()</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">用于同步执行Task任务，代码如下：</span></p><pre data-language=\"csharp\" id=\"dXFUJ\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Task task = new Task(() =&gt;\n    {\n        Thread.Sleep(100);\n        Console.WriteLine(&quot;执行Task结束!&quot;);\n    });\n    //同步执行，task会阻塞主线程\n    task.RunSynchronously();\n    Console.WriteLine(&quot;执行主线程结束！&quot;);\n    Console.ReadKey();\n}</code></pre><p id=\"uace03568\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">执行结果如下：</span></p><p id=\"u7df7f286\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/3.png\" width=\"311\" id=\"u6b0f1b1b\" class=\"ne-image\"></p><h2 id=\"iKFge\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">Task的阻塞方法(Wait/WaitAll/WaitAny)</span></strong></h2><p id=\"u302fc0fa\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">task.Wait()</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 表示等待task执行完毕，功能类似于thead.Join()； </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Task.WaitAll(Task[] tasks)</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 表示只有所有的task都执行完成了再解除阻塞； </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Task.WaitAny(Task[] tasks) </span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">表示只要有一个task执行完毕就解除阻塞，看一个例子： </span></p><pre data-language=\"csharp\" id=\"z6n33\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Task task1 = new Task(() =&gt; {\n        Thread.Sleep(500);\n        Console.WriteLine(&quot;线程1执行完毕！&quot;);\n    });\n    task1.Start();\n    Task task2 = new Task(() =&gt; {\n        Thread.Sleep(1000);\n        Console.WriteLine(&quot;线程2执行完毕！&quot;);\n    });\n    task2.Start();\n    //阻塞主线程。task1,task2都执行完毕再执行主线程\n\t//执行【task1.Wait();task2.Wait();】可以实现相同功能\n    Task.WaitAll(new Task[]{ task1,task2});\n    Console.WriteLine(&quot;主线程执行完毕！&quot;);\n    Console.ReadKey();\n}</code></pre><p id=\"u80f0106e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">执行结果如下：</span></p><p id=\"ue84e92a6\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/8.png\" width=\"298\" id=\"u061482c3\" class=\"ne-image\"></p><p id=\"u31904869\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">如果将例子中的WaitAll换成WaitAny，那么任一task执行完毕就会解除线程阻塞，执行结果是：先打印【线程1执行完毕】，然后打印【主线程执行完毕】，最后打印【线程2执行完毕】。</span></p><h2 id=\"GUoZv\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">Task的延续操作(WhenAny/WhenAll/ContinueWith)</span></strong></h2><p id=\"u7ab8d09a\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">上边的Wait/WaitAny/WaitAll方法返回值为void，这些方法单纯的实现阻塞线程。我们现在想让所有task执行完毕(或者任一task执行完毕)后，开始执行后续操作，怎么实现呢？这时就可以用到WhenAny/WhenAll方法了，这些方法执行完成返回一个task实例。 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">task.WhenAll(Task[] tasks)</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 表示所有的task都执行完毕后再去执行后续的操作， </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">task.WhenAny(Task[] tasks)</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 表示任一task执行完毕后就开始执行后续操作。看一个例子：</span></p><pre data-language=\"csharp\" id=\"Wt0UH\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Task task1 = new Task(() =&gt; {\n        Thread.Sleep(500);\n        Console.WriteLine(&quot;线程1执行完毕！&quot;);\n    });\n    task1.Start();\n    Task task2 = new Task(() =&gt; {\n        Thread.Sleep(1000);\n        Console.WriteLine(&quot;线程2执行完毕！&quot;);\n    });\n    task2.Start();\n    //task1，task2执行完了后执行后续操作\n    Task.WhenAll(task1, task2).ContinueWith((t) =&gt; {\n        Thread.Sleep(100);\n        Console.WriteLine(&quot;执行后续操作完毕！&quot;);\n    });\n    Console.WriteLine(&quot;主线程执行完毕！&quot;);\n    Console.ReadKey();\n}</code></pre><p id=\"uca9dc97b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">执行结果如下，我们看到WhenAll/WhenAny方法不会阻塞主线程，当使用WhenAll方法时所有的task都执行完毕才会执行后续操作；如果把栗子中的WhenAll替换成WhenAny，则只要有一个线程执行完毕就会开始执行后续操作，这里不再演示。</span></p><p id=\"uabfce375\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/9.png\" width=\"292\" id=\"u4d52e86e\" class=\"ne-image\"></p><p id=\"ucb8c9f91\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">上边的例子也可以通过  </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Task.Factory.ContinueWhenAll(Task[] tasks, Action continuationAction) </span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">和  </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Task.Factory.ContinueWhenAny(Task[] tasks, Action continuationAction)</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 来实现 ，修改上边栗子代码如下，执行结果不变。</span></p><pre data-language=\"csharp\" id=\"Yeurm\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n {\n     Task task1 = new Task(() =&gt; {\n         Thread.Sleep(500);\n         Console.WriteLine(&quot;线程1执行完毕！&quot;);\n     });\n     task1.Start();\n     Task task2 = new Task(() =&gt; {\n         Thread.Sleep(1000);\n         Console.WriteLine(&quot;线程2执行完毕！&quot;);\n     });\n     task2.Start();\n     //通过TaskFactroy实现\n     Task.Factory.ContinueWhenAll(new Task[] { task1, task2 }, (t) =&gt;\n     {\n         Thread.Sleep(100);\n         Console.WriteLine(&quot;执行后续操作&quot;);\n     });\n     Console.WriteLine(&quot;主线程执行完毕！&quot;);\n     Console.ReadKey();\n }</code></pre><h2 id=\"ZSmdV\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">Task的任务取消(CancellationTokenSource)</span></strong></h2><p id=\"ue495bd64\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Task中有一个专门的类  </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">CancellationTokenSource</span></code><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 来取消任务执行，还是使用上边的例子，我们修改代码如下，程序运行的效果不变。</span></p><pre data-language=\"csharp\" id=\"L1vmA\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    CancellationTokenSource source = new CancellationTokenSource();\n    int index = 0;\n    //开启一个task执行任务\n    Task task1 = new Task(() =&gt;\n      {\n          while (!source.IsCancellationRequested)\n          {\n              Thread.Sleep(1000);\n              Console.WriteLine($&quot;第{++index}次执行，线程运行中...&quot;);\n          }\n      });\n    task1.Start();\n    //五秒后取消任务执行\n    Thread.Sleep(5000);\n    //source.Cancel()方法请求取消任务，IsCancellationRequested会变成true\n    source.Cancel();\n    Console.ReadKey();\n}</code></pre><p id=\"u06b113ea\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">  CancellationTokenSource的功能不仅仅是取消任务执行，我们可以使用  </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(204, 255, 255)\">source.CancelAfter(</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); background-color: rgb(204, 255, 255)\">5000</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(204, 255, 255)\">)</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">实现5秒后自动取消任务，也可以通过 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(204, 255, 255)\">source.Token.Register(Action action)</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(204, 255, 255)\"></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">注册取消任务触发的回调函数，即任务被取消时注册的action会被执行。 看一个例子：</span></p><pre data-language=\"csharp\" id=\"uB9l5\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    CancellationTokenSource source = new CancellationTokenSource();\n    //注册任务取消的事件\n    source.Token.Register(() =&gt;\n    {\n        Console.WriteLine(&quot;任务被取消后执行xx操作！&quot;);\n    });\n    int index = 0;\n    //开启一个task执行任务\n    Task task1 = new Task(() =&gt;\n      {\n          while (!source.IsCancellationRequested)\n          {\n              Thread.Sleep(1000);\n              Console.WriteLine($&quot;第{++index}次执行，线程运行中...&quot;);\n          }\n      });\n    task1.Start();\n    //延时取消，效果等同于Thread.Sleep(5000);source.Cancel();\n    source.CancelAfter(5000);\n    Console.ReadKey();\n}</code></pre><p id=\"u007e9b9d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">执行结果如下，第5次执行在取消回调后打印，这是因为，执行取消的时候第5次任务已经通过了while()判断，任务已经执行中了：</span></p><p id=\"uc4d6dcd5\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/10.png\" width=\"295\" id=\"u38c803e9\" class=\"ne-image\"></p><h2 id=\"t2ZDq\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">Task的暂停线程处理</span></h2><p id=\"u165b62ed\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task.Delay不会阻塞线程（而Thread.Sleep(xxxx) 会阻塞线程），线程可以继续处理其他的工作。</span></p><pre data-language=\"csharp\" id=\"E8Zmy\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Console.WriteLine(&quot;Main前&quot;);\n    ShowDelayAsync();\n    Console.WriteLine(&quot;Main后&quot;);\n    Console.ReadKey();\n}\nprivate static async void ShowDelayAsync()\n{\n    Console.WriteLine(&quot;async前&quot;);\n    await Task.Delay(1000);\n    Console.WriteLine(&quot;async后&quot;);\n}</code></pre><p id=\"u5e288826\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果：</span></p><p id=\"u37ba4534\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/13.png\" width=\"173\" id=\"ue09c140a\" class=\"ne-image\"></p><pre data-language=\"csharp\" id=\"Qx2L0\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Console.WriteLine(&quot;Main前&quot;);\n    ShowDelayAsync().Wait();\n    Console.WriteLine(&quot;Main后&quot;);\n    Console.ReadKey();\n}\nprivate static async Task ShowDelayAsync()\n{\n    Console.WriteLine(&quot;async前&quot;);\n    await Task.Delay(1000);\n    Console.WriteLine(&quot;async后&quot;);\n}\n\n//或者\nstatic async void Main(string[] args)\n{\n    Console.WriteLine(&quot;Main前&quot;);\n    await  ShowDelayAsync();\n    Console.WriteLine(&quot;Main后&quot;);\n    Console.ReadKey();\n}\nprivate static async Task ShowDelayAsync()\n{\n    Console.WriteLine(&quot;async前&quot;);\n    await Task.Delay(1000);\n    Console.WriteLine(&quot;async后&quot;);\n}</code></pre><p id=\"uc2b69c37\" class=\"ne-p\"><span class=\"ne-text\">运行结果</span></p><p id=\"u251bf961\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/14.png\" width=\"69.33333333333333\" id=\"uff8ddbcb\" class=\"ne-image\"></p><div class=\"ne-quote\"><p id=\"u7317157e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 12px\">注：对于异步方法A()，使用await A()会将当前线程释放，让其他线程可以继续工作，等待异步方法A()的执行完成后再继续执行后续代码。而使用A().wait()会阻塞当前线程，直到异步方法A()执行完成后才会继续执行后续代码。因此，推荐使用await A()来实现异步编程。</span></p></div><h1 id=\"I4FkH\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">async/await</span></h1><p id=\"u77d1bcde\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">在C#5.0中出现的 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); background-color: rgb(204, 255, 255)\">async和await</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\"> ，让异步编程变得更简单。我们看一个获取文件内容的例子：</span></p><pre data-language=\"csharp\" id=\"wyEZo\" class=\"ne-codeblock language-csharp\"><code>class Program\n{\n    static void Main(string[] args)\n    {\n        //test.txt内容是【hello world！】\n        string content = GetContentAsync(Environment.CurrentDirectory + @&quot;/test.txt&quot;).Result;\n        //调用同步方法\n        //string content = GetContent(Environment.CurrentDirectory + @&quot;/test.txt&quot;);\n        Console.WriteLine(content);\n        Console.ReadKey();\n    }\n    //异步读取文件内容\n    async static Task&lt;string&gt; GetContentAsync(string filename)\n    {\n        \n        FileStream fs = new FileStream(filename, FileMode.Open);\n        var bytes = new byte[fs.Length];\n        //ReadAync方法异步读取内容，不阻塞线程\n        Console.WriteLine(&quot;开始读取文件&quot;);\n        int len = await fs.ReadAsync(bytes, 0, bytes.Length);\n        string result = Encoding.UTF8.GetString(bytes);\n        return result;\n    }\n    //同步读取文件内容\n    static string GetContent(string filename)\n    {\n        FileStream fs = new FileStream(filename, FileMode.Open);\n        var bytes = new byte[fs.Length];\n        //Read方法同步读取内容，阻塞线程\n        int len =  fs.Read(bytes, 0, bytes.Length);\n        string result = Encoding.UTF8.GetString(bytes);\n        return result;\n    }\n}</code></pre><p id=\"u6295524f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">执行结果为：</span></p><p id=\"ud6e9f94e\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/11.png\" width=\"167\" id=\"ud78602c8\" class=\"ne-image\"></p><p id=\"u15f800c5\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">上边的例子也写出了同步读取的方式，将main函数中的注释去掉即可同步读取文件内容。我们可以看到异步读取代码和同步读取代码基本一致。</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">async/await</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">让异步编码变得更简单，我们可以像写同步代码一样去写异步代码。注意一个小问题：异步方法中方法签名返回值为 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task&lt;T&gt;</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">，代码中的返回值为T。上边例子中 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">GetContentAsync</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">的签名返回值为 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task&lt;string&gt;</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">，而代码中返回值为string。牢记这一细节对我们分析异步代码很有帮助。</span></p><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u01254eb0\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">所有带有Async关键字的异步方法返回类型：</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"uab28e282\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task&lt;T&gt;：如果调用方法想通过调用异步方法获取一个T类型的返回值，那么签名必须为 </span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task&lt;TResult&gt;</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">；</span></li><li id=\"ue5b07182\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task:如果调用方法不想通过异步方法获取一个值，仅仅想追踪异步方法的执行状态，那么我们可以设置异步方法签名的返回值为Task;</span></li><li id=\"u2bb2e38e\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">void:如果调用方法仅仅只是调用一下异步方法，不和异步方法做其他交互，我们可以设置异步方法签名的返回值为void，这种形式也叫做“调用并忘记”。</span></li></ol></ol><p id=\"uffa7fb01\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">即：</span><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">异步方法的返回值类型必须为Task或Task&lt;T&gt;；</span></strong></p><ol start=\"2\" class=\"ne-ol\"><li id=\"udf9aa216\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">异步方法的“传染性“：</span><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">一个方法中如果有await调用，则这个方法也必须修饰为async。</span></strong></li><li id=\"u7b21aab7\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\"></span><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">在async方法中遇到await关键字后，当前线程立即返回(到调用方)，继续之前的处理逻辑；await关键字之后的代码逻辑，将交由新的线程处理；当新的线程处理完成后，可以从新的线程返回处理结果到调用(处)线程当中，结束等待。</span></strong></li><li id=\"u5b1cb841\" data-lake-index-type=\"0\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">在一个async方法中，会根据await关键字进行分割，拆分到不同的线程处理同一个方法的不同部分！</span></strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">如下例：</span></li></ol><pre data-language=\"csharp\" id=\"Wh4tj\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Console.WriteLine(&quot;{0}-&gt;Main.异步方法执行前&quot;, Thread.CurrentThread.ManagedThreadId.ToString());//输出异步处理之前的线程ID\n    DoAsync(1000).Wait();//执行异步处理，并等待该异步方法执行完成后才继续\n    Console.WriteLine(&quot;{0}-&gt;Main.异步方法执行后&quot;, Thread.CurrentThread.ManagedThreadId.ToString());//输出异步处理之后的线程ID\n    Console.Read();\n}\n/// &lt;summary&gt;\n/// 执行异步处理\n/// &lt;/summary&gt;\n/// &lt;param name=&quot;times&quot;&gt;模拟处理时长&lt;/param&gt;\n/// &lt;returns&gt;&lt;/returns&gt;\npublic static async Task DoAsync(int times)\n{\n    Console.WriteLine(&quot;{0}-&gt;DoAsync.await之前&quot;, Thread.CurrentThread.ManagedThreadId.ToString());//输出调用线程ID\n    await Task.Run(() =&gt; Thread.Sleep(times));///执行一个异步任务，并等待返回结果才继续；需要注意的是，调用线程执行到这一行的时候其实就已经返回了\n    Console.WriteLine(&quot;{0}-&gt;DoAsync.await之后&quot;, Thread.CurrentThread.ManagedThreadId.ToString());//异步操作执行完了，但这里已经是新的线程了\n}</code></pre><p id=\"u02c7b140\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 12px\">运行结果：</span></p><p id=\"u2c8f896a\" class=\"ne-p\" style=\"text-align: left\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/12.png\" width=\"255\" id=\"ufdf56d89\" class=\"ne-image\"></p><div data-type=\"color2\" class=\"ne-alert\"><p id=\"u493de2b8\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">请注意：</span></p><ol class=\"ne-ol\"><li id=\"u19afb795\" data-lake-index-type=\"0\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">在同步方法Main中执行的时候都是同一个线程；</span></strong></li><li id=\"u37b0ff2a\" data-lake-index-type=\"0\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">在异步方法DoAsync执行的时候，在await之前是调用线程，在await之后则是另一个线程。</span></strong></li></ol></div><ol start=\"5\" class=\"ne-ol\"><li id=\"u63b36a9e\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 16px\">把一个方法代码的不同部分拆分到多个线程处理，这是异步方法和同步方法的最大不同！</span></strong></li></ol><p id=\"ua4d584fa\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119475983/image/0.png\" width=\"581\" id=\"ClsF3\" class=\"ne-image\"></p><p id=\"ua84a4609\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 12px\">总而言之：</span></p><div class=\"ne-quote\"><p id=\"u42806542\" class=\"ne-p\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: rgb(255, 102, 0); font-size: 12px\">在异步(async)方法执行中，会根据await关键字，拆分一个方法为多个部分，分别由不同的线程执行。</span></strong></p></div><div class=\"ne-quote\"><p id=\"uc5690f7d\" class=\"ne-p\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: rgb(51, 102, 255); font-size: 12px\">在异步(async)方法执行中，遇到await关键字，调用线程会立即返回(线程池)继续后续的处理逻辑；而后，调用方可以使用Task.Wait()或Task&lt;T&gt;.Result进行阻塞，等待异步方法执行完毕再继续。</span></strong></p></div><div class=\"ne-quote\"><p id=\"u30085b5f\" class=\"ne-p\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: rgb(255, 0, 255); font-size: 12px\">在异步(async)方法执行后，若不使用Task.Wait()进行等待，或不使用Task&lt;T&gt;.Result获取返回结果，则该方法将仅以异步方式执行。</span></strong></p></div><p id=\"ue3a67832\" class=\"ne-p\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">小结</span></strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">：到这里Task，async/await的简单使用已经基本结束了，一些高级特性等到工作遇到了再去研究。通过上边的介绍，我们知道</span><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">async/await是基于Task的</span></strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">，而</span><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task是对ThreadPool的封装改进</span></strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">，主要是为了更有效的控制线程池中的线程(ThreadPool中的线程，我们很难通过代码控制其执行顺序，任务延续和取消等等)；</span><strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">ThreadPool基于Thread的</span></strong><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">，主要目的是减少Thread创建数量和管理Thread的成本。</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">async/await</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">、</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">Task</span></code><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">是C#中更先进的，也是微软大力推广的特性，我们在开发中可以尝试使用Task来替代Thread/ThreadPool，处理本地IO和网络IO任务是尽量使用async/await来提高任务执行效率。</span></p><p id=\"u943eec54\" class=\"ne-p\"><br></p><p id=\"u29624c90\" class=\"ne-p\"><span class=\"ne-text\"></span></p></div>",
  "body": null,
  "CosUpdatedAt": "0001-01-01T00:00:00",
  "BodyHtmlCosUrl": null
}