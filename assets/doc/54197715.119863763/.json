{
  "UUID": "54197715.119863763",
  "id": 0,
  "type": null,
  "format": null,
  "title": "网络协议-SOCKET【Area】",
  "tags": null,
  "slug": null,
  "Tags": null,
  "description": null,
  "cover": null,
  "book_id": 0,
  "BookName": null,
  "public": 0,
  "word_count": 0,
  "created_at": "0001-01-01T00:00:00",
  "updated_at": "0001-01-01T00:00:00",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h1 id=\"UhKkK\"><span class=\"ne-text\">分层介绍</span></h1><p id=\"u9a278e7e\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">以下是各层功能描述：</span></p><p id=\"u3f26ce9a\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/1.png\" width=\"494\" id=\"ucd3f29d3\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/10.png\" width=\"514.6666666666666\" id=\"u2e603d78\" class=\"ne-image\"></p><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u6f223120\" data-lake-index-type=\"2\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">物理层协议</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">：</span><span class=\"ne-text\" style=\"font-size: 13px\"><br /></span><span class=\"ne-text\" style=\"font-size: 16px\">负责0、1</span><span class=\"ne-text\" style=\"font-size: 16px\"> </span><strong><span class=\"ne-text\" style=\"font-size: 16px\">比特流</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">（0/1序列）与电压的高低、逛的闪灭之间的转换。</span><span class=\"ne-text\" style=\"font-size: 16px\">规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性；该层为上层协议提供了一个传输数据的物理媒体，只是说明标准。<br /></span><span class=\"ne-text\" style=\"font-size: 16px\">在这一层，数据的单位称为</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">比特（bit）</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">（注：bit和字节Byte，我们常说的1字节8位2进制即：1B=8bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45、fddi令牌环网。</span></li><li id=\"u93807fd8\" data-lake-index-type=\"2\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">数据链路层协议</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">：</span><span class=\"ne-text\" style=\"font-size: 13px\"><br /></span><span class=\"ne-text\" style=\"font-size: 16px\">负责物理层面上的互联的、节点间的通信传输（例如一个以太网项链的2个节点之间的通信）；该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。<br /></span><span class=\"ne-text\" style=\"font-size: 16px\">在这一层，数据的单位称为</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">帧（frame）</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">。</span><span class=\"ne-text\" style=\"font-size: 16px\">数据链路层协议的代表包括：ARP、RARP、SDLC、HDLC、PPP、STP、帧中继等。</span></li><li id=\"u1639f803\" data-lake-index-type=\"2\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">网络层协议</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">：</span><span class=\"ne-text\" style=\"font-size: 13px\"><br /></span><span class=\"ne-text\" style=\"font-size: 16px\">将数据</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">传输到目标地址</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">；目标地址可以使多个网络通过路由器连接而成的某一个地址，主要负责寻</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">找地址和路由选择</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，网络层还可以实现拥塞控制、网际互连等功能。<br /></span><span class=\"ne-text\" style=\"font-size: 16px\">在这一层，数据的单位称为</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">数据包（packet）</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">。</span><span class=\"ne-text\" style=\"font-size: 16px\">网络层协议的代表包括：IP、IPX、RIP、OSPF等。</span></li><li id=\"u4c6b8ceb\" data-lake-index-type=\"2\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">传输层协议</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">（核心层）：</span><span class=\"ne-text\" style=\"font-size: 13px\"><br /></span><span class=\"ne-text\" style=\"font-size: 16px\">传输层是OSI中最重要、最关键的一层,是唯一负责总体的数据传输和数据控制的一层；<br /></span><span class=\"ne-text\" style=\"font-size: 16px\">传输层提供端到端的交换数据的机制，检查分组编号与次序，传输层对其上三层如会话层等，提供可靠的传输服务,对网络层提供可靠的目的地站点信息主要功能。</span><span class=\"ne-text\" style=\"font-size: 16px\">在这一层，数据的单位称为数据段（segment）。</span><span class=\"ne-text\" style=\"font-size: 16px\">主要功能：</span><span class=\"ne-text\" style=\"font-size: 16px\">①：为端到端连接提供</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">传输服务</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">。</span><span class=\"ne-text\" style=\"font-size: 16px\">②：这种传输服务分为可靠和不可靠的,其中Tcp是典型的可靠传输,而Udp则是不可靠传输。</span><span class=\"ne-text\" style=\"font-size: 16px\">③：为端到端连接提供流量控制,差错控制,服务质量(Quality of Service,QoS)等</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">管理服务</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">。</span><span class=\"ne-text\" style=\"font-size: 16px\">包括的协议如下：</span><span class=\"ne-text\" style=\"font-size: 16px\">TCP：传输控制协议，传输效率低，可靠性强。</span><span class=\"ne-text\" style=\"font-size: 16px\">UDP：用户数据报协议，适用于传输可靠性要求不高，数据量小的数据。</span><span class=\"ne-text\" style=\"font-size: 16px\">DCCP、SCTP、RTP、RSVP、PPTP等协议。</span></li><li id=\"udd8e26c7\" data-lake-index-type=\"2\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">会话层协议：</span></strong><span class=\"ne-text\" style=\"font-size: 16px\"><br /></span><span class=\"ne-text\" style=\"font-size: 16px\">负责建立和断开通信连接（数据流动的逻辑通路），记忆数据的分隔等数据传输相关的管理</span><span class=\"ne-text\" style=\"font-size: 16px\">。</span></li><li id=\"u65036e30\" data-lake-index-type=\"2\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">表示层协议：</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">将数据格式转换为标准格式<br /></span><span class=\"ne-text\" style=\"font-size: 16px\"> 将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式；主要负责数据格式的转换，确保一个系统的应用层信息可被另一个系统应用层读取。</span><span class=\"ne-text\" style=\"font-size: 16px\">具体来说，就是</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">将设备固有的数据格式转换为网络标准传输格式</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，不同设备对同一比特流解释的结果可能会不同；因此，主要负责使它们保持一致。</span></li><li id=\"u18d6b90b\" data-lake-index-type=\"2\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">应用层协议：</span></strong></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"ufb6ff7d5\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">超文本传输协议HTTP：</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">这是一种最基本的</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">客户机/服务器的访问协议</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">；浏览器向服务器发送请求，而服务器回应相应的网页。</span></li><li id=\"uf8c3dc89\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">文件传送协议FTP</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">：提供交互式的访问，基于客户服务器模式，面向连接 使用TCP可靠的运输服务。主要功能:减少/消除不同操作系统下文件的不兼容性。</span></li><li id=\"ue7071570\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\"></span></strong><span class=\"ne-text\" style=\"font-size: 16px\">远程登录协议TELNET：客户服务器模式，能适应许多计算机和操作系统的差异，网络虚拟终端NVT的意义。</span></li><li id=\"u44c4812f\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">简单邮件传送协议SMTP</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">：Client/Server模式，面向连接。基本功能：写信、传送、报告传送情况、显示信件、接收方处理信件。</span></li><li id=\"ubda582be\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">DNS域名解析协议：</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">DNS是一种用以将域名转换为IP地址的Internet服务。</span></li><li id=\"u78f10859\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\"></span></strong><span class=\"ne-text\" style=\"font-size: 16px\">简单文件传送协议TFTP：客户服务器模式，使用UDP数据报，只支持文件传输，不支持交互，TFTP代码占内存小。</span></li><li id=\"ued5345d8\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\"></span></strong><span class=\"ne-text\" style=\"font-size: 16px\">简单网络管理协议（SNMP）: SNMP模型的4个组件：被管理结点、管理站、管理信息、管理协议。SNMP代理：运行SNMP管理进程的被管理结点。</span></li><li id=\"u2b873188\" data-lake-index-type=\"2\"><strong><span class=\"ne-text\" style=\"font-size: 16px\"></span></strong><span class=\"ne-text\" style=\"font-size: 16px\">DHCP动态主机配置协议: 发现协议中的引导文件名、空终止符、属名或者空,DHCP供应协议中的受限目录路径名 Options –可选参数字段，参考定义选择列表中的选择文件。</span></li></ol></ol><p id=\"u0b0ae542\" class=\"ne-p\" style=\"text-align: left; margin-left: 2em\"><span class=\"ne-text\" style=\"font-size: 16px\">注：其实协议分层只是为了更好地理解我运用协议的作用，而不是绝对的分层，有的层之间协议也是可以共用的，特别是会话层、表示层和应用层这三层。</span></p><p id=\"u7c55ffb1\" class=\"ne-p\" style=\"text-align: left; margin-left: 2em\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/11.png\" width=\"696.6666666666666\" id=\"ucb9947f1\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/12.png\" width=\"696.6666666666666\" id=\"u601427dd\" class=\"ne-image\"></p><h1 id=\"qsut5\"><span class=\"ne-text\" style=\"color: rgb(34, 34, 38)\">TCP的三次握手和四次挥手</span></h1><p id=\"u61ec2065\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/8.png\" width=\"640\" id=\"uefd4c0b7\" class=\"ne-image\"></p><p id=\"uc2993559\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/13.png\" width=\"666.6666666666666\" id=\"u9390b7bc\" class=\"ne-image\"></p><ul class=\"ne-ul\"><li id=\"u245f84b3\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">源端口</span></strong><span class=\"ne-text\">：客户端（发送方）对应应用的的端口号，某个应用发起网络请求时，操作系统会给它分配一个对应端口号</span></li><li id=\"u00feb726\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">目的端口</span></strong><span class=\"ne-text\">：服务端（接收方）对应应用的端口号，一般都是启动监听时设置的，比如起了一个tomcat，端口号为8080</span></li><li id=\"u3bed92e3\" data-lake-index-type=\"0\"><span class=\"ne-text\">序号</span><span class=\"ne-text\">（Sequence Number）：序号的语义和控制标志位SYN的值有关。</span></li></ul><p id=\"uc5a3658a\" class=\"ne-p\" style=\"margin-left: 2em\"><span class=\"ne-text\">当SYN=1时，当前TCP报文为刚开始建立连接的阶段。序号的值为ISN（初始化序列号），是根据计时器、源IP、目的IP、源端口、目的端口等条件随机生成的；</span></p><p id=\"u5711e8df\" class=\"ne-p\" style=\"margin-left: 2em\"><span class=\"ne-text\">当SYN=0时，是正式传输数据的阶段。客户端（发送方）发送数据时，会为每个TCP报文段设置有序的序列号，当前报文段的序号值是所发送的数据的第一个字节的序号。比如客户端要发送3个连续的报文段，每个TCP报文携带的数据长度为2字节，即三个报文的数据分别为【第1个字节+第2个字节】、【第3个字节+第4个字节】、【第5个字节+第6个字节】，那这3个报文段对应的序号分别为1、3、5</span></p><ul class=\"ne-ul\"><li id=\"uf4de1591\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">确认序号</span></strong><span class=\"ne-text\">（Acknowledgement Number）：接收端期望收到发送端下一个报文的序号。</span></li></ul><p id=\"uf9f22fb7\" class=\"ne-p\" style=\"margin-left: 2em\"><span class=\"ne-text\">比如客户端发送了长度为2字节的三个报文【第1个字节+第2个字节】、【第3个字节+第4个字节】、【第5个字节+第6个字节】，即这3个报文段对应的序号分别为1、3、5，那服务端对应回应的3个报文的确认序号分别为3、5、7，意思就是告诉客户端说已收到序号为3之前的所有数据，请继续发送序号为3的数据吧、已收到序号为5之前的所有数据，请继续发送序号为5的数据吧、已收到序号为7之前的所有数据，请继续发送序号为7的数据吧</span></p><ul class=\"ne-ul\"><li id=\"uefe479db\" data-lake-index-type=\"0\"><span class=\"ne-text\">头部长度</span><span class=\"ne-text\">：TCP报文首部的长度，其值表示头部所包含的32bit的倍数，比如TCP头部一共为20字节（5*32bit），那该值就是5</span></li><li id=\"u3c1f2231\" data-lake-index-type=\"0\"><span class=\"ne-text\">保留</span><span class=\"ne-text\">：保留字段</span></li><li id=\"u7e8256e5\" data-lake-index-type=\"0\"><span class=\"ne-text\">控制位：每个控制为占1字节，具体含义如下</span></li></ul><table id=\"xvK9I\" class=\"ne-table\" style=\"width: 784px\"><tbody><tr style=\"height: 33px\"><td width=\"98\"><p id=\"u89f974ab\" class=\"ne-p\"><span class=\"ne-text\" style=\"background-color: #FBDE28\">标志位</span></p></td><td width=\"686\"><p id=\"u3cbc40c8\" class=\"ne-p\"><span class=\"ne-text\" style=\"background-color: #FBDE28\">说明</span></p></td></tr><tr style=\"height: 33px\"><td width=\"98\"><p id=\"u1f2294d7\" class=\"ne-p\"><span class=\"ne-text\">URG</span></p></td><td width=\"686\"><p id=\"u42eb162a\" class=\"ne-p\"><span class=\"ne-text\">占1位，表示紧急指针字段有效。URG位指示报文段里的上层实体（数据）标记为“紧急”数据。当URG=1时，其后的紧急指针指示紧急数据在当前数据段中的位置(相对于当前序列号的字节偏移量)，TCP接收方必须通知上层实体。</span></p></td></tr><tr style=\"height: 92px\"><td width=\"98\"><p id=\"ufcaec55a\" class=\"ne-p\"><span class=\"ne-text\">ACK</span></p></td><td width=\"686\"><p id=\"ub26fb6cd\" class=\"ne-p\"><span class=\"ne-text\">占1位，置位ACK=1表示确认号字段有效；TCP协议规定，接建立后所有发送的报文的ACK必须为1；当ACK=0时，表示该数据段不包含确认信息。当ACK=1时，表示该报文段包括一个对已被成功接收报文段的确认序号Acknowledgment Number，该序号同时也是下一个报文的预期序号。</span></p></td></tr><tr style=\"height: 33px\"><td width=\"98\"><p id=\"u55d75c6c\" class=\"ne-p\"><span class=\"ne-text\">PSH</span></p></td><td width=\"686\"><p id=\"uf77f38d9\" class=\"ne-p\"><span class=\"ne-text\">占1位，表示当前报文需要请求推（push）操作；当PSH=1时，接收方在收到数据后立即将数据交给上层，而不是直到整个缓冲区满。</span></p></td></tr><tr style=\"height: 33px\"><td width=\"98\"><p id=\"u4b247ec1\" class=\"ne-p\"><span class=\"ne-text\">RST</span></p></td><td width=\"686\"><p id=\"u56fa2240\" class=\"ne-p\"><span class=\"ne-text\">占1位，置位RST=1表示复位TCP连接；用于重置一个已经混乱的连接，也可用于拒绝一个无效的数据段或者拒绝一个连接请求。如果数据段被设置了RST位，说明报文发送方有问题发生。</span></p></td></tr><tr style=\"height: 33px\"><td width=\"98\"><p id=\"ud036033c\" class=\"ne-p\"><span class=\"ne-text\">SYN</span></p></td><td width=\"686\"><p id=\"u59c1d7c6\" class=\"ne-p\"><span class=\"ne-text\">占1位，在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1。 综合一下，SYN置1就表示这是一个连接请求或连接接受报文。</span></p></td></tr><tr style=\"height: 33px\"><td width=\"98\"><p id=\"ued97f853\" class=\"ne-p\"><span class=\"ne-text\">FIN</span></p></td><td width=\"686\"><p id=\"u5d4b9cd3\" class=\"ne-p\"><span class=\"ne-text\">占1位，用于在释放TCP连接时，标识发送方比特流结束，用来释放一个连接。当 FIN = 1时，表明此报文的发送方的数据已经发送完毕，并要求释放连接。</span></p></td></tr></tbody></table><ul class=\"ne-ul\"><li id=\"u08b8a539\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\">选项和填充部分：</span></strong><span class=\"ne-text\">这部分不是必填的，可以根据需要增加对应的数据。较常见的选项字段是MSS（Maximum segment size），表示每个TCP报文的数据段的最大长度，MSS只存在于SYN报文中（因此TCP协议是在三次握手阶段协商MSS的大小），一般情况下，MSS的值越大，网络利用率越高，但是也有可能降低网络速度。TCP协议一般通过MTU来确定MSS的值，在MTU中，IP数据报的大小不超过1500字节，而IP数据报的首部20字节，所以TCP报文段不超过1480字节；TCP报文段首部20字节，所以TCP携带的数据不超过1460字节，即MSS最大值为1460。【MTU：最大控制单元，数据链路层要求帧的大小不能超过1518字节（14 字节的帧头 + 4 字节帧校验和 + 最多 1500 字节数据），这1500字节的数据就是MTU】</span></li></ul><p id=\"u59754bb0\" class=\"ne-p\"><span class=\"ne-text\"></span></p><p id=\"u76d0ba6f\" class=\"ne-p\"><span class=\"ne-text\">TCP的三次握手和四次挥手实质就是TCP通信的连接和断开。</span></p><p id=\"u526be5ec\" class=\"ne-p\"><span class=\"ne-text\">三次握手：为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。</span></p><p id=\"uf197c405\" class=\"ne-p\"><span class=\"ne-text\">四次挥手：即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</span></p><p id=\"uaa644e7c\" class=\"ne-p\"><span class=\"ne-text\">TCP三次握手、四次挥手时序图</span></p><p id=\"udc66dd1b\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/2.png\" width=\"801\" id=\"ub73814e1\" class=\"ne-image\"></p><ol data-index-type=\"1\" class=\"ne-ol\"><li id=\"u474f22ff\" data-lake-index-type=\"1\"><strong><span class=\"ne-text\" style=\"font-size: 22px\">三次握手</span></strong></li></ol><p id=\"udc2394d2\" class=\"ne-p\"><strong><span class=\"ne-text\">TCP协议位于传输层</span></strong><span class=\"ne-text\">，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。</span></p><ol class=\"ne-ol\"><li id=\"u6baa84c3\" data-lake-index-type=\"0\"><span class=\"ne-text\">三次握手的作用</span></li></ol><div class=\"ne-quote\"><ul class=\"ne-ul\"><li id=\"u38a3af1c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\">确认双方的接受能力、发送能力是否正常。</span></li><li id=\"ue2ea68c4\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\">指定自己的初始化序列号，为后面的可靠传送做准备。</span></li></ul></div><ol start=\"2\" class=\"ne-ol\"><li id=\"ucbf909b1\" data-lake-index-type=\"0\"><span class=\"ne-text\">三次握手的目的</span></li></ol><p id=\"u7f489060\" class=\"ne-p\"><span class=\"ne-text\">第一次握手：客户端给服务器发送一个报文，告知服务器：“我客户端想和你建立连接”。</span></p><div class=\"ne-quote\"><p id=\"ue3afba27\" class=\"ne-p\"><span class=\"ne-text\">服务器收到第一段报文后得出结论：客户端发送功能正常，服务器接收功能正常。</span></p></div><p id=\"ue2711c76\" class=\"ne-p\"><span class=\"ne-text\">第二次握手：服务器收到报文后给客户端回复一个报文，告知客户端：“我服务器收到了你的请求，同意和你建立连接”。</span></p><div class=\"ne-quote\"><p id=\"u54cbb6c9\" class=\"ne-p\"><span class=\"ne-text\">客户端收到第二段报文后得出结论：客户端发送和接收功能都正常，服务器的发送接收功能也都正常。（但此时服务器不能确认客户端的接收功能和自己的发送功能是否正常）。</span></p></div><p id=\"u673bdabf\" class=\"ne-p\"><span class=\"ne-text\">第三次握手：客户端收到第二段报文后给服务器回复一个报文，告知服务器：“我客户端收到了你的回复，知道你同意连接，那我们开始连接吧！”</span></p><div class=\"ne-quote\"><p id=\"u77cfe536\" class=\"ne-p\"><span class=\"ne-text\">服务器收到第三段报文后得出结论：客户端的接收功能和服务器的发送功能也都正常。</span></p></div><p id=\"ubebac348\" class=\"ne-p\"><span class=\"ne-text\">所以当服务器收到第三个报文后，两边就建立起了TCP连接。</span></p><ol start=\"3\" class=\"ne-ol\"><li id=\"u7793c5cd\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">两次握手为什么不行？</span></li></ol><div class=\"ne-quote\"><p id=\"u2d8ab02d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(85, 86, 102); background-color: rgb(238, 240, 244); font-size: 16px\">那么两次握手为什么不行就显而易见了，只有前两次握手的话，服务器就不能确认自己回复的报文段是否被客户端接收到，</span><strong><span class=\"ne-text\" style=\"color: #DF2A3F; background-color: rgb(238, 240, 244); font-size: 16px\">也就不知道自己的发送功能和客户端的接收功能是否正常。</span></strong></p></div><ol start=\"4\" class=\"ne-ol\"><li id=\"u5ba090ad\" data-lake-index-type=\"0\"><span class=\"ne-text\">三次握手原理：</span></li></ol><div class=\"ne-quote\"><p id=\"u119d0097\" class=\"ne-p\"><span class=\"ne-text\">第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；</span></p><p id=\"ud6e9ce1a\" class=\"ne-p\"><span class=\"ne-text\">第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；</span></p><p id=\"u33eb3366\" class=\"ne-p\"><span class=\"ne-text\">第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。</span></p></div><p id=\"u6c0efcc7\" class=\"ne-p\"><span class=\"ne-text\">置位概念：根据TCP的包头字段，存在3个重要的标识ACK、SYN、FIN</span></p><p id=\"u1732e855\" class=\"ne-p\"><span class=\"ne-text\">ACK：表示验证字段</span></p><p id=\"uef76b96b\" class=\"ne-p\"><span class=\"ne-text\">SYN：位数置1，表示建立TCP连接</span></p><p id=\"uab073d43\" class=\"ne-p\"><span class=\"ne-text\">FIN：位数置1，表示断开TCP连接</span></p><p id=\"u118604a9\" class=\"ne-p\"><span class=\"ne-text\">可通过以下趣味图解理解三次握手：</span></p><p id=\"u58c67828\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/3.png\" width=\"871\" id=\"u85e94824\" class=\"ne-image\"></p><ol start=\"5\" class=\"ne-ol\"><li id=\"u68fec1d3\" data-lake-index-type=\"0\"><span class=\"ne-text\">三次握手过程详细说明：</span></li></ol><div data-type=\"color2\" class=\"ne-alert\"><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"ud15add9a\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；</span></li><li id=\"u13734290\" data-lake-index-type=\"2\"><span class=\"ne-text\">服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；</span></li><li id=\"uf1e91a8a\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。</span></li></ol></div><ol start=\"2\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"uad97c8fe\" data-lake-index-type=\"1\"><strong><span class=\"ne-text\" style=\"font-size: 22px\">四次挥手</span></strong></li></ol><p id=\"u23e4110c\" class=\"ne-p\"><span class=\"ne-text\">由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</span></p><ol class=\"ne-ol\"><li id=\"u17cd155b\" data-lake-index-type=\"0\"><span class=\"ne-text\">为什么挥手需要四次？</span></li></ol><p id=\"u87ce821d\" class=\"ne-p\"><span class=\"ne-text\">这个问题可以换一种问法，也就是：中间两个步骤为什么不能合并呢？只要服务器收到客户端的FIN报文后，同时发送ACK报文和FIN报文不就可以三次挥手断开连接吗？</span></p><div class=\"ne-quote\"><p id=\"ua034ad9f\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F\">不行：要保证数据的完整性</span></strong></p><p id=\"uc1d190d2\" class=\"ne-p\"><span class=\"ne-text\">答案1：是通常情况下不行，因为ACK和FIN的触发时机是不一样的。我们要搞清楚一件事：服务器在收到FIN报文后可以立即发送ACK报文，表明我服务器收到了你的报文；但是服务器想发送FIN报文就需要等到处理完接收缓冲区的数据后才可以。所以挥手需要四次。</span></p><p id=\"uf7569990\" class=\"ne-p\"><span class=\"ne-text\">答案2：参照三次握手机制，挥手最少需要三次，如果只有三次，客户端发送完数据请求断开连接，而服务端不一定也同样发送完数据，若同时回ACK和FIN给客户端，断开连接，可能造成数据的损坏；若先发送ACK，再等B的数据发送完了再发送FIN和ACK，就可以</span><strong><span class=\"ne-text\">保证传输数据的完整性</span></strong><span class=\"ne-text\">。</span></p></div><ol start=\"2\" class=\"ne-ol\"><li id=\"u4c87babc\" data-lake-index-type=\"0\"><span class=\"ne-text\">为什么要等待2MSL？（为什么会存在一个TIME_WAIT状态？）</span></li></ol><p id=\"u64128f00\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\">虽然四个报文都发送完毕，可以进入CLOSE状态，但是网络可能会存在不可靠假象，有可能最后一个ACK丢失，TIME-WAIT状态就是用来重新发送可能丢失的报文。</span></p><div class=\"ne-quote\"><p id=\"u76411239\" class=\"ne-p\"><span class=\"ne-text\">等待2msl的意义：可靠的终止TCP连接、保证迟来的TCP报文有足够的时间被识别并丢弃；</span></p><ol class=\"ne-ol\"><li id=\"u2bfaa66c\" data-lake-index-type=\"0\"><span class=\"ne-text\">保证A发送的ACK能够顺利到达B，这个报文可能丢失，处在LAST-ACK的B收不到对自己以发送的FIN和ACK报文的确认，B会超时重传FIN和ACK报文，那么在2msl时间内收到这个重传的FIN+ACK报文，接着A重传一次；</span></li><li id=\"ua021ac30\" data-lake-index-type=\"0\"><span class=\"ne-text\">在这个期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用，这个连接只能在2msl结束后才能被使用；</span></li><li id=\"u59b0e0fa\" data-lake-index-type=\"0\"><span class=\"ne-text\">为了使旧的数据包在网络中因过期而消失，每个具体的TCP必须选择一个报文最大生存时间MSL，它是任何报文字段被丢弃前在网络内的最长时间。</span></li></ol></div><p id=\"uec895dc6\" class=\"ne-p\"><br></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ue48f51b6\" data-lake-index-type=\"0\"><span class=\"ne-text\">四次挥手原理：</span></li></ol><div class=\"ne-quote\"><p id=\"u7a740966\" class=\"ne-p\"><span class=\"ne-text\">第1次挥手：</span></p><ul class=\"ne-ul\"><li id=\"u9d65e0a0\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgba(0, 0, 0, 0.75); font-size: 16px\">客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</span></li></ul><p id=\"u04809638\" class=\"ne-p\"><span class=\"ne-text\">第2次挥手：</span></p><ul class=\"ne-ul\"><li id=\"u10a91f95\" data-lake-index-type=\"0\"><span class=\"ne-text\">服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；</span></li></ul><p id=\"uad2c29d5\" class=\"ne-p\"><span class=\"ne-text\">第3次挥手：</span></p><ul class=\"ne-ul\"><li id=\"u3a37e06a\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgba(0, 0, 0, 0.75); font-size: 16px\">客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</span></li></ul><p id=\"ueb2ec06b\" class=\"ne-p\"><span class=\"ne-text\">第4次挥手：</span></p><ul class=\"ne-ul\"><li id=\"u10c8fe99\" data-lake-index-type=\"0\"><span class=\"ne-text\">客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态</span></li><li id=\"u43c3b9e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。</span></li><li id=\"uad9c7d04\" data-lake-index-type=\"0\"><span class=\"ne-text\">客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。</span></li></ul></div><p id=\"u2088fc1e\" class=\"ne-p\"><br></p><p id=\"u45f15ca5\" class=\"ne-p\"><span class=\"ne-text\">其中：FIN标志位数置1，表示断开TCP连接。</span></p><p id=\"u2c8b862b\" class=\"ne-p\"><span class=\"ne-text\">可通过以下趣味图解理解四次挥手：</span></p><p id=\"u8187654f\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/4.png\" width=\"797\" id=\"u5b3fbbe9\" class=\"ne-image\"></p><p id=\"u9bec25c0\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/7.png\" width=\"720\" id=\"mDDXC\" class=\"ne-image\"></p><ol start=\"4\" class=\"ne-ol\"><li id=\"u1cf77246\" data-lake-index-type=\"0\"><span class=\"ne-text\">四次挥手过程详细说明：</span></li></ol><div data-type=\"color2\" class=\"ne-alert\"><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u1dfcddd8\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；</span></li><li id=\"u8179e9e4\" data-lake-index-type=\"2\"><span class=\"ne-text\">服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）；</span></li><li id=\"u38d94597\" data-lake-index-type=\"2\"><span class=\"ne-text\">服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）；</span></li><li id=\"u230f452c\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）</span></li></ol></div><p id=\"u8cb233ae\" class=\"ne-p\"><span class=\"ne-text\">至此TCP断开的4次挥手过程完毕。</span></p><ol start=\"3\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"u290fba98\" data-lake-index-type=\"1\"><strong><span class=\"ne-text\" style=\"font-size: 22px\">11种状态名词解析</span></strong></li></ol><p id=\"ua080ed5b\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/5.png\" width=\"660\" id=\"ua24834e8\" class=\"ne-image\"></p><div class=\"ne-quote\"><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u2ec21c49\" data-lake-index-type=\"2\"><span class=\"ne-text\">一开始，建立连接之前服务器和客户端的状态都为CLOSED；</span></li><li id=\"ufe4c5043\" data-lake-index-type=\"2\"><span class=\"ne-text\">服务器创建socket后开始监听，变为LISTEN状态；</span></li><li id=\"u3def8cce\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT；</span></li><li id=\"udccfb1ff\" data-lake-index-type=\"2\"><span class=\"ne-text\">服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD；</span></li><li id=\"u7a84e24f\" data-lake-index-type=\"2\"><span class=\"ne-text\">然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED；</span></li><li id=\"u259a5c7d\" data-lake-index-type=\"2\"><span class=\"ne-text\">服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立！</span></li></ol></div><p id=\"u7b7f1705\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/6.png\" width=\"624\" id=\"ua9c0c872\" class=\"ne-image\"></p><div class=\"ne-quote\"><p id=\"u9901b52f\" class=\"ne-p\"><span class=\"ne-text\">由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。</span></p><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u56fa9ae8\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1；</span></li><li id=\"u51bced75\" data-lake-index-type=\"2\"><span class=\"ne-text\">服务器收到FIN后向客户端发送ACK，服务器的状态围边CLOSE_WAIT；</span></li><li id=\"uc63d8466\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送；</span></li><li id=\"ud342065d\" data-lake-index-type=\"2\"><span class=\"ne-text\">直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态；</span></li><li id=\"u6a60e773\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态；</span></li><li id=\"ue219cb5e\" data-lake-index-type=\"2\"><span class=\"ne-text\">再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。至此，还有一个状态没有出来：CLOSING状态。</span></li></ol><p id=\"u94f3152d\" class=\"ne-p\"><span class=\"ne-text\">CLOSING状态表示：</span></p><p id=\"u09c95231\" class=\"ne-p\"><span class=\"ne-text\">客户端发送了FIN，但是没有收到服务器的ACK，却收到了服务器的FIN，这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。</span></p></div><pre data-language=\"plain\" id=\"HwQwO\" class=\"ne-codeblock language-plain\"><code>LISTEN：等待从任何远端TCP 和端口的连接请求。\n \nSYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。\n \nSYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。\n \nESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。\n \nFIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。\n \nFIN_WAIT_2：等待远端TCP 的连接终止请求。\n \nCLOSE_WAIT：等待本地用户的连接终止请求。\n \nCLOSING：等待远端TCP 的连接终止请求确认。\n \nLAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）\n \nTIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。\nTIME_WAIT 两个存在的理由：\n          1.可靠的实现tcp全双工连接的终止；\n          2.允许老的重复分节在网络中消逝。\n \nCLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）</code></pre><h1 id=\"FkYQ3\"><span class=\"ne-text\">TCP通过序列号保证数据顺序传输</span></h1><p id=\"ucd64ee4c\" class=\"ne-p\"><span class=\"ne-text\">TCP通过序列号(</span><code class=\"ne-code\"><span class=\"ne-text\">Sequence Number</span></code><span class=\"ne-text\">)来保证数据的顺序传输。这个过程涉及TCP报文首部中的序列号和确认号(</span><code class=\"ne-code\"><span class=\"ne-text\">Acknowledgment Number</span></code><span class=\"ne-text\">)字段。</span></p><p id=\"u0d9d0191\" class=\"ne-p\"><span class=\"ne-text\">具体过程如下:</span></p><div class=\"ne-quote\"><ol class=\"ne-ol\"><li id=\"ufa201163\" data-lake-index-type=\"0\"><span class=\"ne-text\">连接建立时,客户端和服务器会随机初始化一个序列号发给对方。比如客户端选择序列号x,服务器选择序列号y。</span></li><li id=\"u51ca02bd\" data-lake-index-type=\"0\"><span class=\"ne-text\">客户端发送第1个报文,序列号设置为x,确认号设置为x+1(即期望收到服务器的下一个报文序号)。</span></li><li id=\"ucee32092\" data-lake-index-type=\"0\"><span class=\"ne-text\">服务器收到客户端报文,获得x和x+1序列号,并发送第1个报文,序列号设置为y,确认号设置为y+1。</span></li><li id=\"u76a42187\" data-lake-index-type=\"0\"><span class=\"ne-text\">客户端收到服务器报文,获得y和y+1序列号,这个时候就与服务器建立了序号同步。</span></li><li id=\"u2d61e028\" data-lake-index-type=\"0\"><span class=\"ne-text\">客户端继续发送第2个报文,序列号设置为x+1,确认号仍为y+1。服务器接收,发送第2个报文,序列号y+1,确认号x+2。</span></li><li id=\"ue8d9d281\" data-lake-index-type=\"0\"><span class=\"ne-text\">这样,每发送一个报文,序列号就+1,确认号就是对方下一条预期报文的序号。这就实现了顺序传输。</span></li><li id=\"uf219f553\" data-lake-index-type=\"0\"><strong><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">如果某个报文没有收到确认,就进行重传,这也就实现了可靠传输。</span></strong></li></ol></div><p id=\"ufc6e86c7\" class=\"ne-p\"><span class=\"ne-text\">例如,一次完整会话如下:</span></p><p id=\"u6f68a91e\" class=\"ne-p\"><span class=\"ne-text\">客户端: SYN=x, ACK=x+1</span></p><p id=\"ufd5348ca\" class=\"ne-p\"><span class=\"ne-text\">服务器: SYN=y, ACK=y+1</span></p><p id=\"u5e0b7464\" class=\"ne-p\"><span class=\"ne-text\">客户端: ACK=y+1, SEQ=x+1</span></p><p id=\"u864171f2\" class=\"ne-p\"><span class=\"ne-text\">服务器: ACK=x+2, SEQ=y+1</span></p><p id=\"u7b65a993\" class=\"ne-p\"><span class=\"ne-text\">客户端: ACK=y+2, SEQ=x+2</span></p><p id=\"u827dae1e\" class=\"ne-p\"><span class=\"ne-text\">服务器: ACK=x+3, SEQ=y+2</span></p><p id=\"ub1ef6d48\" class=\"ne-p\"><span class=\"ne-text\">在这个过程中,每个报文的序列号是按顺序递增的,同时确认号是对方下一条预期报文的序号。</span></p><p id=\"u6169f354\" class=\"ne-p\"><span class=\"ne-text\">如果某一方收到的确认号不是自己下一条要发送的数据的序列号,就说明中间有报文丢失,需要重传。</span></p><p id=\"u6c090a64\" class=\"ne-p\"><span class=\"ne-text\">所以,通过这个序号机制,TCP能够保证按发送顺序完整可靠地传输数据。这也是TCP能提供可靠有序传输的原因。</span></p><h1 id=\"DJP5O\"><span class=\"ne-text\">Socket如何保密</span></h1><p id=\"ue2577d99\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119863763/image/9.png\" width=\"698\" id=\"uc8382567\" class=\"ne-image\"></p><h2 id=\"JVGzX\"><span class=\"ne-text\">流程解释</span></h2><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u92caadd9\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端创建连接(建立websocket/socket通讯)，申请AES密钥。</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"u81b25851\" data-lake-index-type=\"2\"><span class=\"ne-text\">当连接创建成功后客户端所发出去的第一个包是通过RSA公钥加密的，其目的就是为了和服务器端申请后续通讯所使用的AES密钥。</span></li></ol></ol><ol start=\"2\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"u3b1854a9\" data-lake-index-type=\"2\"><span class=\"ne-text\">而服务器当收到客户端的请求AES密钥的请求包时</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"ucdedc04b\" data-lake-index-type=\"2\"><span class=\"ne-text\">通过RSA私钥解密请求包，并验证消息</span></li><li id=\"u4149abd8\" data-lake-index-type=\"2\"><span class=\"ne-text\">为本次连接临时生成一个AES密钥(缓存在服务器端)并返回给客户端。也就是说AES密钥每次都会变的，而不是一个固定的值。</span></li></ol></ol><ol start=\"3\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"u703ca42c\" data-lake-index-type=\"2\"><span class=\"ne-text\">客户端获取AES密钥并缓存，好了此时针对本次的连接,客户端/服务器端均有AES密钥，</span></li></ol><p id=\"uc83b19b6\" class=\"ne-p\"><span class=\"ne-text\">那么后续的通讯数据均通过这个AES密钥进行加密解密。</span></p><h2 id=\"evPNH\"><span class=\"ne-text\">规范约定</span></h2><ol class=\"ne-ol\"><li id=\"uded944c2\" data-lake-index-type=\"0\"><span class=\"ne-text\">RSA,密钥长度1024, 填充方式PKCS1,公钥加密，私钥解密，公钥可通过私钥生成</span></li><li id=\"u855b7add\" data-lake-index-type=\"0\"><span class=\"ne-text\">AES使用AES/ECB/PKCS7Padding</span></li></ol><h2 id=\"tC14T\"><span class=\"ne-text\">RSA加密</span></h2><ul class=\"ne-ul\"><li id=\"u5117f7ec\" data-lake-index-type=\"0\"><span class=\"ne-text\">RSA加密规则:若密钥位数是key_size, 单次加密串的最大长度为 (key_size)/8 - 11, 目前位数1024, 则最大加密长度为117，为了方便这里我们选择一次加密长度为100</span></li><li id=\"u78b13be5\" data-lake-index-type=\"0\"><span class=\"ne-text\">将明文数据分成一个或数个最长100字节的小段进行加密，拼接分段加密数据即为最终的Body加密数据</span></li></ul><h2 id=\"vx9Qe\"><span class=\"ne-text\">RSA解密</span></h2><ul class=\"ne-ul\"><li id=\"u17080c7f\" data-lake-index-type=\"0\"><span class=\"ne-text\">RSA解密同样遵循分段规则，对于1024位密钥, 每小段待解密数据长度为128字节</span></li><li id=\"uf5a8c99c\" data-lake-index-type=\"0\"><span class=\"ne-text\">将密文数据分成一个或数个128字节长的小段进行解密，拼接分段解密数据即为最终的Body解密数据</span></li></ul><h2 id=\"cQci1\"><span class=\"ne-text\">AES加密</span></h2><ul class=\"ne-ul\"><li id=\"u88de7264\" data-lake-index-type=\"0\"><span class=\"ne-text\">AES加密要求源数据长度必须是16的整数倍, 故需补‘0’对齐后再加密，记录modlen为源数据长度与16取模值</span></li><li id=\"u8184391c\" data-lake-index-type=\"0\"><span class=\"ne-text\">因加密前有可能对源数据作修改， 故需在加密后的数据尾再增加一个16字节的填充数据块，其最后一个字节赋modlen, 其余字节赋值‘0’， 将加密数据和额外的填充数据块拼接作为最终要发送协议的body数据</span></li></ul><h2 id=\"t2E26\"><span class=\"ne-text\">AES解密</span></h2><ul class=\"ne-ul\"><li id=\"ubb64fdb0\" data-lake-index-type=\"0\"><span class=\"ne-text\">协议body数据, 先将最后一个字节取出，记录modlen， 然后将body截掉尾部16字节填充数据块后再解密(与加密填充额外数据块逻辑对应)</span></li><li id=\"ua2a649ed\" data-lake-index-type=\"0\"><span class=\"ne-text\">modlen 为0时，上述解密后的数据即为协议返回的body数据, 否则需截掉尾部(16 - 录modlen)长度的用于填充对齐的数据</span></li></ul><p id=\"ub40b0262\" class=\"ne-p\"><br></p><h1 id=\"ApCrx\"><span class=\"ne-text\">长连接和短连接的区别</span></h1><ol class=\"ne-ol\"><li id=\"uc5432fd9\" data-lake-index-type=\"0\"><span class=\"ne-text\">使用方法不同。</span></li></ol><div class=\"ne-quote\" style=\"margin-left: 2em\"><ol class=\"ne-ol\"><li id=\"ua067447c\" data-lake-index-type=\"0\"><span class=\"ne-text\">长连接是client方与server方先建立连接，连接建立后不断开，然后再进行报文发送和接收。</span></li><li id=\"ubc990088\" data-lake-index-type=\"0\"><span class=\"ne-text\">短连接是Client方与server每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。</span></li></ol></div><ol start=\"2\" class=\"ne-ol\"><li id=\"u91170136\" data-lake-index-type=\"0\"><span class=\"ne-text\">操作过程不同</span></li></ol><div class=\"ne-quote\" style=\"margin-left: 2em\"><ol class=\"ne-ol\"><li id=\"u94c067d1\" data-lake-index-type=\"0\"><span class=\"ne-text\">长连接的操作步骤是：建立连接、数据传输..、保持连接、数据传输、关闭连接。</span></li><li id=\"u8db8c382\" data-lake-index-type=\"0\"><span class=\"ne-text\">短连接的操作步骤是：建立连接、数据传输、关闭连接、建立连接、数据传输、关闭连接。</span></li></ol></div><ol start=\"3\" class=\"ne-ol\"><li id=\"u9293ef60\" data-lake-index-type=\"0\"><span class=\"ne-text\">使用时机不同</span></li></ol><div class=\"ne-quote\" style=\"margin-left: 2em\"><ol class=\"ne-ol\"><li id=\"u9918e003\" data-lake-index-type=\"0\"><span class=\"ne-text\">长连接：短连接多用于操作频繁，点对点的通讯，而且长连接数不能太多的情况。每个TCP连接的建立都需要三次握手，每个TCP连接的断开要四次握手。</span></li><li id=\"u15dae1c3\" data-lake-index-type=\"0\"><span class=\"ne-text\">短连接：web网站的http服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像web网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。</span></li></ol></div><h1 id=\"aooho\"><span class=\"ne-text\">Socket粘包分包</span></h1><ul class=\"ne-ul\"><li id=\"u3c6ba8a7\" data-lake-index-type=\"0\"><span class=\"ne-text\">TCP：数据传输是以无边界的数据流传输形式，所谓无边界是指数据发送端发送的字节数，在数据接收端接受时并不一定等于发送的字节数，可能会出现粘包分包情况。</span></li><li id=\"uabe13170\" data-lake-index-type=\"0\"><span class=\"ne-text\">UDP：本身作为无连接的不可靠的传输协议（适合频繁发送较小的数据包），他不会对数据包进行合并发送，每一个数据包都是完整的（数据+UDP头+IP头等等发一次数据封装一次）也就没有粘包分包一说了。</span></li></ul><p id=\"uc3c4a923\" class=\"ne-p\"><span class=\"ne-text\">注：UDP协议是无连接的、不可靠的网络协议,它没有建立链接前的“三次握手”,也没有 ACK 确认机制。所以,UDP每一包数据并不一定是完整的</span></p><ol class=\"ne-ol\"><li id=\"u4567e9ef\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先什么是包</span></li></ol><p id=\"u17c211cc\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">包就是每次服务器向客户端发送的数据每发送一个消息都会被打成一个包发送到客户端。</span></p><p id=\"uad98ed75\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">客户端向服务器端发送消息也是一样的。</span></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u432179bc\" data-lake-index-type=\"0\"><span class=\"ne-text\">为什么会有粘包和分包的问题</span></li></ol><p id=\"u27a93397\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">是因为SocketTCP自身的优化机制所导致的。</span></p><ol start=\"3\" class=\"ne-ol\"><li id=\"u12568688\" data-lake-index-type=\"0\"><span class=\"ne-text\">什么是粘包</span></li></ol><p id=\"u38e47a5f\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">粘包就是当服务器端发送的数据很小的时候又很频繁的时候，就会消耗性能，所以SocketTCP就会把几个数据包打成一个包发送到客户端，来进行优化网络。</span></p><ol start=\"4\" class=\"ne-ol\"><li id=\"uec143f3c\" data-lake-index-type=\"0\"><span class=\"ne-text\">什么是分包</span></li></ol><p id=\"u8893c7e0\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">分包就是当服务器端发送的消息特别大的时候，它的传输速度就会特别慢，还有可能是发送中途会失败，这个时候这条消息就要在次重新发送一次，非常消耗性能和时间，为了避免这样的事情发生，SocketTCP自身优化机制就会把这条特别大的消息分开为N个小包发送到客户端，提高消息的传输速度与安全性，就算中间有个别的包丢失了，也不用重新全部发送一遍而是单独发送一遍丢失的小包就好了。</span></p><ol start=\"5\" class=\"ne-ol\"><li id=\"u54c0ac39\" data-lake-index-type=\"0\"><span class=\"ne-text\">粘包或者分包后接到的顺序是什么样的</span></li></ol><p id=\"u9264cbbf\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">虽然经过分包或者粘包，但是他的</span><strong><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">先后顺序是不会变</span></strong><span class=\"ne-text\">的。</span></p><p id=\"ucbe40a92\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">比如第一条消息是1第二条是2那么他接收到的粘包数据就是12。</span></p><p id=\"u56258e82\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">分包也是一样，分包粘包不会影响数据的顺序，只是会影响接收的次数。</span></p><ol start=\"6\" class=\"ne-ol\"><li id=\"uadad4831\" data-lake-index-type=\"0\"><span class=\"ne-text\">什么时候会出现这种问题</span></li></ol><p id=\"u9e655607\" class=\"ne-p\"><span class=\"ne-text\">\t</span><span class=\"ne-text\">例如：在Unity中某个游戏物体的坐标需要实时的同步，这个时候就会出现粘包问题因为它的数据非常小只有xyz的坐标数据，但是每秒要同步很多次，造成了数据传输频繁数据又非常小就会出现粘包的现象。</span></p><ol class=\"ne-ol\"><li id=\"u195702e8\" data-lake-index-type=\"0\"><span class=\"ne-text\">粘包分包的解决方案</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" class=\"ne-ol\"><li id=\"u5cd4b117\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">固定长度分包</span><span class=\"ne-text\">：应用程序在发送数据时，将每个数据包的长度固定为一个固定值。接收方在接收数据时，每次读取固定长度的数据，直到接收完整个数据包。这种方法简单易行，但是对于长度不固定的数据包无法处理。</span></li><li id=\"ueab16365\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">包尾标识分包</span><span class=\"ne-text\">：应用程序在发送数据时，在每个数据包的末尾添加一个特定的标识符，表示数据包的结束。接收方在接收数据时，按照这个标识符来确定每个数据包的边界。这种方法需要应用程序在发送数据时添加标识符，对于像XML这样的格式化数据不太适用。</span></li><li id=\"u2b9f2e80\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">包头+包体分包</span><span class=\"ne-text\">：应用程序在发送数据时，在每个数据包的开头添加一个</span><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">固定长度的包头</span><span class=\"ne-text\">，包头中记录了该数据包的长度信息。接收方在接收数据时，先读取包头，再按照包头中记录的长度来读取数据包。这种方法比较通用，但是需要应用程序在发送数据时添加包头，增加了数据传输的开销。</span></li><li id=\"u6c32f074\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">使用特定的分隔符</span><span class=\"ne-text\">：应用程序在发送数据时，使用特定的字符或字符串作为分隔符来分隔每个数据包。接收方在接收数据时，按照分隔符来确定每个数据包的边界。这种方法比较简单易行，但是需要保证分隔符与数据内容不冲突。</span></li><li id=\"u323964f7\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(249,57,87)\">使用消息队列</span><span class=\"ne-text\">：应用程序将发送的数据放入消息队列中，接收方从消息队列中读取数据，每次读取一个完整的数据包。这种方法对于高并发的场景比较适用，但是需要引入消息队列的开销。</span></li></ol></ol><p id=\"ub59201e5\" class=\"ne-p\"><span class=\"ne-text\">总的来说，不同的应用场景需要选择不同的解决方案，综合考虑数据包的长度、格式、传输速度、并发量等因素，选择最合适的方案来解决粘包和分包问题。</span></p></div>",
  "body": null,
  "CosUpdatedAt": "0001-01-01T00:00:00",
  "BodyHtmlCosUrl": null
}