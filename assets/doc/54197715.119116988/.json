{
  "UUID": "54197715.119116988",
  "id": 0,
  "type": null,
  "format": null,
  "title": "C#-内存管理(Stack和Heap)【Area】",
  "tags": null,
  "slug": null,
  "Tags": null,
  "description": null,
  "cover": null,
  "book_id": 0,
  "BookName": null,
  "public": 0,
  "word_count": 0,
  "created_at": "0001-01-01T00:00:00",
  "updated_at": "0001-01-01T00:00:00",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"u155e09c1\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">每个线程对应一个stack，线程创建的时候CLR为其创建这个stack，stack主要作用是记录函数的执行情况。值类型变量（函数的参数、局部变量 等非成员变量）都分配在stack中，引用类型的对象分配在heap中，在stack中保存heap对象的引用指针。GC只负责heap对象的释放，heap内存空间管理。</span></p><p id=\"uf7566732\" class=\"ne-p\" style=\"text-indent: 2em\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119116988/image/0.png\" width=\"452\" id=\"u53f96320\" class=\"ne-image\"></p><p id=\"u387b51bb\" class=\"ne-p\" style=\"text-indent: 2em\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">除去pinned object等影响，heap中的内存分配很简单，一个指针记录heap中分配的起始地址，根据对象大小连续的分配内存。</span></p><h2 id=\"C8O9b\"><strong><span class=\"ne-text\" style=\"color: rgb(36, 41, 46)\">Stack结构</span></strong></h2><p id=\"u2afce59b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46)\">每个函数调用时，逻辑上在thread stack中会产生一个帧（stack frame），函数返回时对应的stack frame被释放掉。</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\" style=\"color: rgb(36, 41, 46)\">用个简单的函数查看执行时CLR对栈的处理情况：</span></p><pre data-language=\"csharp\" id=\"FJxQS\" class=\"ne-codeblock language-csharp\">static void Main(string[] args)\n{\n\tint r = Sum(2, 3, 4, 5, 6);\n}\nprivate static int Sum(int a, int b, int c, int d, int e)\n{\n\treturn a + b + c + d + e;\n}</pre><p id=\"uc814223c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">JIT编译后主要汇编代码如下（其他的情况下汇编代码可能有所差别，但用这个简单函数大致看下栈的管理已经足够）：</span></p><div data-type=\"tips\" class=\"ne-alert\"><p id=\"u0be80c09\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;====函数Main====</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">push</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    </span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">4</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">         </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;第3个参数到最后一个参数压栈<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">push</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    </span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">5</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    <br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">push</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    </span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">6</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    <br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    edx,</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">3</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">   </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;第1、第2个参数分别放入ecx、edx寄存器<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    ecx,</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">2</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\"> <br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">call</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    dword ptr </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 128); font-size: 16px\">ds:</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">[00AD96B8h]  </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;调用函数Sum，执行call的时候返回地址（即下面这条mov语句的地址）自动压栈了<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    dword ptr [ebp-0Ch],eax   </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;将函数返回值设置到局部变量r中（函数调用结束返回值在eax寄存器中）<br /><br />;====函数Sum====</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">push</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    ebp           </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;保存原始ebp寄存器<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    ebp,esp     </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;将当前栈指针保存在ebp中，后面使用ebp对参数和局部变量寻址<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">sub</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    esp,</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">8</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">         </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;分配两个局部变量<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    dword ptr [ebp-</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">4</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">],ecx         </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;第1个参数放入局部变量<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    dword ptr [ebp-</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">8</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">],edx         </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;第2个参数放入局部变量<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">......     </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;CLR的检查代码</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\"><br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    eax,dword ptr [ebp-</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">4</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">]          </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;a + b + c + d + e<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">add</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    eax,dword ptr [ebp-</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">8</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">]          </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;第1个参数+第2个参数（2+3）<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">add</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    eax,dword ptr [ebp+10h]      </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;+第3个参数（4）<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">add</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    eax,dword ptr [ebp+0Ch]      </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;+第4个参数（5）<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">add</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    eax,dword ptr [ebp+</span><span class=\"ne-text\" style=\"color: rgb(128, 0, 128); font-size: 16px\">8</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">]          </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;+第5个参数（6）<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">mov</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    esp,ebp    </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;恢复栈指针（局部变量被释放了）<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">pop</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    ebp          </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;恢复原始的ebp寄存器值<br /></span><span class=\"ne-text\" style=\"color: rgb(0, 0, 255); font-size: 16px\">ret</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0); font-size: 16px\">    0Ch   </span><span class=\"ne-text\" style=\"color: rgb(0, 128, 0); font-size: 16px\">;函数返回. 1: 返回地址自动出 栈; 2: esp减去0Ch（12个字节），即从栈中清除调用参 数; 3: 返回值在eax寄存器中</span></p></div><p id=\"u3f5d6077\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 16px\">执行时刻的stack状态如下（栈基地址为高端地址，栈顶为低端地址）：</span></p><p id=\"ud69a261a\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119116988/image/1.png\" width=\"258\" id=\"u3b7a22fa\" class=\"ne-image\"></p><p id=\"u6c91c2cc\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">Stack状态变化过程：</span></p><ol class=\"ne-ol\"><li id=\"u5a446b65\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">调用者将第3、第4、第5个参数压栈，第1、第2个参数分别放入ecx、edx寄存器</span></li><li id=\"u05026c1f\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">call指令调用函数Sum，并自动将函数返回地址压栈，代码跳转到函数Sum开始执行</span></li><li id=\"uf225037a\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">函数Sum先将寄存器ebp压栈保存，并将esp放入ebp，用于后面对参数和局部变量寻址</span></li><li id=\"u002311f7\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">定义局部变量以及省略掉的是额外代码，跟Sum函数业务无关</span></li><li id=\"ucf7816c6\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">执行加法操作，结果保存在eax寄存器中</span></li><li id=\"udbfa0beb\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\"> 恢复esp寄存器，这样函数Sum中所有的局部变量以及其他压栈操作全部释放出来</span></li><li id=\"u2fb63ecb\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">原始ebp的值出栈，恢复ebp，这样栈完全恢复到进入Sum函数调用时的状态</span></li><li id=\"u77cb10b5\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">ret指令执行函数返回，返回值在eax寄存器中，返回地址为call指令压栈的地址，返回地址自动出栈。0Ch指示处理器在函数返回时释放栈中12个字 节，即由被调用者清除压栈的参数。函数返回之后，本次Sum调用的栈分配全部释放</span></li></ol><p id=\"ud5993b6c\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\"> 这种调用约定类似__fastcall</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">    结合引用类型变量、值类型的ref参数，下面代码简化的stack状态如下：</span></p><pre data-language=\"csharp\" id=\"oC8ps\" class=\"ne-codeblock language-csharp\">public static void Run(int i)\n{\n    int j = 9;\n    MyClass1 c = new MyClass1();\n    c.x = 8;\n    int result = Sum(i, 5, ref j, c);\n}\n\npublic static int Sum(int a, int b, ref int c, MyClass1 obj)\n{\n    int r = a + b + c + obj.x;\n    return r;\n}\n\npublic class MyClass1\n{\n    public int x;\n}</pre><p id=\"u5b9f1d74\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">Stack状态：</span></p><p id=\"uc15f05f3\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119116988/image/2.png\" width=\"475\" id=\"u311eafb7\" class=\"ne-image\"></p><p id=\"u00d4790f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(36, 41, 46); font-size: 14px\">任何时候引用类型都分配在heap中，在stack中只是保存对象的引用地址。Run函数执行完毕之后，heap中的MyClass1对象c成为可回收的垃圾对象，在GC时进行回收。</span></p></div>",
  "body": null,
  "CosUpdatedAt": "0001-01-01T00:00:00",
  "BodyHtmlCosUrl": null
}