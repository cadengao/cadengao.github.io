[
  {
    "UUID": "54197715.119109318",
    "id": 0,
    "type": null,
    "format": null,
    "title": "C#-垃圾回收机制(GC)【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "什么是GC官网中有这么一句话：The garbage collector is a common language runtime component that controls the allocation and release of managed memory。垃圾回收机制（Garba...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119110971",
    "id": 0,
    "type": null,
    "format": null,
    "title": "C#-资源类型(托管资源和非托管资源)【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "分为托管资源和非托管资源：托管资源指的是.NET可以自动进行回收的资源，主要是指托管堆上分配的内存资源。托管资源的回收工作是不需要人工干预的，由.NET运行库在合适时机调用垃圾回收器进行回收。非托管资源指的是.NET不知道如何回收的资源，最常见的一类非托管资源是包装操作系统资源的对象，例如：文...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119116988",
    "id": 0,
    "type": null,
    "format": null,
    "title": "C#-内存管理(Stack和Heap)【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "每个线程对应一个stack，线程创建的时候CLR为其创建这个stack，stack主要作用是记录函数的执行情况。值类型变量（函数的参数、局部变量 等非成员变量）都分配在stack中，引用类型的对象分配在heap中，在stack中保存heap对象的引用指针。GC只负责heap对象的释放，heap...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119122075",
    "id": 0,
    "type": null,
    "format": null,
    "title": "C#-CLR、内存分配和内存回收【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "CLRCLR：即公共语言运行时(Common Language Runtime)，是中间语言（IL）的运行时环境，负责将编译生成的MSIL编译成计算机可以识别的机器码，负责资源管理（内存分配和垃圾回收等）。可能有人会提问：为什么不直接编译成机器码，而要先编译成IL，然后在编译成机器码呢？原因是...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119475983",
    "id": 0,
    "type": null,
    "format": null,
    "title": "C#-异步编程【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "什么是异步同步和异步主要用于修饰方法。当一个方法被调用时，调用者需要等待该方法执行完毕并返回才能继续执行，我们称这个方法是同步方法；当一个方法被调用时立即返回，并获取一个线程执行该方法内部的业务，调用者不用等待该方法执行完毕，我们称这个方法为异步方法。Thread < ThreadPoll <...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119594211",
    "id": 0,
    "type": null,
    "format": null,
    "title": "WPF-MVVM(使用MvvmLight插件)【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "MVVM介绍其实就是：Model 、view、viewmodel三个的简称，就像MVC一样。model就是模型。view就是视图。viewmodel就是和view进行绑定的。MVVM示意图如下所示：安装MvvmLight插件MVVM开发步骤主要通过MVVM实现数据的CRUD【增删改查】基础操作...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119613878",
    "id": 0,
    "type": null,
    "format": null,
    "title": "WPF-命令(ICommand)【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "使用Command可以实现UI层跟业务层分离，不必在UI层定义事件方法，近而减少耦合。开发示例界面展示_UI层<Window x:Class=\"WpfCommand.MainWindow\"         xmlns=\"http://schemas.microsoft.com/winfx/20...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119618116",
    "id": 0,
    "type": null,
    "format": null,
    "title": "WPF-通知更改INotifyPropertyChanged【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "有两种方式简单方式-在赋值的时候调用PropertyChangednamespace WpfApp1 {     public class MainViewModel:INotifyPropertyChanged     {         public MyCommand ShowComma...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119618807",
    "id": 0,
    "type": null,
    "format": null,
    "title": "WPF-绑定【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "开发示例<Window x:Class=\"WpfApp1.Window4\"   xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"   xmlns:x=\"http://schemas.microsoft.com/w...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  },
  {
    "UUID": "54197715.119619453",
    "id": 0,
    "type": null,
    "format": null,
    "title": "WPF-依赖属性【Area】",
    "tags": null,
    "slug": null,
    "Tags": null,
    "description": "依赖属性介绍WPF提供了一组服务，这些服务可用于扩展公共语言运行时 (CLR) 属性的功能。 这些服务通常统称为 WPF 属性系统。 由 WPF 属性系统支持的属性称为依赖属性。为什么要使用依赖属性场景一：一个界面有100个按钮，每个按钮有100个属性，那么系统需要为10000个属性分配内存，...",
    "cover": null,
    "book_id": 0,
    "BookName": null,
    "public": 0,
    "word_count": 0,
    "created_at": "0001-01-01T00:00:00",
    "updated_at": "0001-01-01T00:00:00",
    "body_html": null,
    "body": null,
    "CosUpdatedAt": "0001-01-01T00:00:00",
    "BodyHtmlCosUrl": null
  }
]