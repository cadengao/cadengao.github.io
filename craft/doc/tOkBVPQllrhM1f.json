{
  "schemaVersion": "1",
  "spaceId": "d8d537f0-b7d4-e6fe-0216-30e666a82048",
  "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
  "blocks": [
    {
      "id": "069FA684-867D-4B29-8EED-D00F0844C9B8",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": ".NET的GC机制有这样两个问题：",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687242378060
    },
    {
      "id": "06F053CF-DF52-4955-9F97-3A4A4B36A890",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPHLHLuaXE1Ha6GHqCWq3ikJAkTuDmU4sFdoqt89bmVsRhD49a6Bn1aDuaCDdHx8gjggjUmiKsgepwDVwsAVvRnZ8KLWbeuRyczf12k3tNhPnhq65qC3YmJzu6CjPxydjfcKnCuQTMUHx35NDDm2gqcxVvk",
      "pageStyleData": "{}",
      "rawProperties": "{\"aspectRatio\":\"2.3300970873786406\",\"fileExtension\":\"tiff\",\"fileName\":\"Image.tiff\",\"isPreviewImageUploaded\":\"true\",\"mimeType\":\"image/tiff\",\"previewImageWidth\":\"1200.0\",\"primaryColor\":\"16777215\",\"rawDataSize\":\"7617592\",\"rawUrl\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPHLHLuaXE1Ha6GHqCWq3ikJAkTuDmU4sFdoqt89bmVsRhD49a6Bn1aDuaCDdHx8gjggjUmiKsgepwDVwsAVvRnZ8KLWbeuRyczf12k3tNhPnhq65qC3YmJzu6CjPxydjfcKnCuQTMUHx35NDDm2gqcxVvk/Image.jpg\",\"uploaded\":\"true\",\"url\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyij2hXZ9ktkCSwi5dEzpLycdYcUPUxzquMxAw2pdw5Duzpitjm4Dce8eHE3GhyKrmZB6dwpSeUHxM9iQaixPaycZu6oEeRebGtxFU6qxfXKQonqCekzXFS7Ruv82fPvvUNKj2RPVLsaVjRn1q6LkgCWbNrxyxEVfcmP22CLaejPA2gf6F6VDPXv5jkSpEje2bZdestR6c3VRXXApTwKiBfdnQREF43T3CkgZ2LugAxnf35EAn5cq9Y1XAmwMkBkdCbgtYfo5/Image.jpg\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364588456,
      "type": "image",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"imageFillStyle\":\"scaleAspectFit\",\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687446671176
    },
    {
      "id": "0A3E7500-1021-48EE-9067-A3F8302574BB",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "“清除”本领——回收内存：启用压缩（Compact）算法，对内存中存活的对象进行移动，修改它们的指针，使之在内存中连续，这样空闲的内存也就连续了，这就解决了内存碎片问题，当再次为新对象分配内存时，CLR不必在充满碎片的内存中寻找适合新对象的内存空间，所以分配速度会大大提高。但是大对象（large object heap）除外，GC不会移动一个内存中巨无霸，因为它知道现在的CPU不便宜。通常，大对象具有很长的生存期，当一个大对象在.NET托管堆中产生时，它被分配在堆的一个特殊部分中，移动大对象所带来的开销超过了整理这部分堆所能提高的性能。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[1,2]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"bullet\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378058
    },
    {
      "id": "0F20F320-D619-44C1-8721-9940A72AED5A",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "/// <summary>\n/// 执行SQL语句，返回影响的记录数\n/// </summary>\n/// <param name=\"SQLString\">SQL语句</param>\n/// <returns>影响的记录数</returns>\npublic static int ExecuteSql(string SQLString)\n{\n    using (SqlConnection connection = new SqlConnection(connectionString))\n    {\n        using (SqlCommand cmd = new SqlCommand(SQLString, connection))\n        {\n            try\n            {\n                connection.Open();\n                int rows = cmd.ExecuteNonQuery();\n                return rows;\n            }\n            catch (System.Data.SqlClient.SqlException e)\n            {\n                connection.Close();\n                throw e;\n            }\n            finally\n            {\n                cmd.Dispose();\n                connection.Close();\n            }\n        }\n    }\n}",
      "rawProperties": "{\"language\":\"cs\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "code",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "pluginData": "{\"horizontalSizeClass\":\"regular\",\"pluginConfigurationData\":\"{\\\"themeId\\\":\\\"auto\\\"}\",\"pluginName\":\"codeBlock\",\"surfaceShadowOpacity\":0,\"verticalSizeClass\":\"regular\"}",
      "updated": 1687269152958
    },
    {
      "id": "0F4873AD-D49C-4EFE-A084-FA23D8133B85",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364695843,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364695843
    },
    {
      "id": "14092947-B68C-47EC-ABE5-58D3AD6480FD",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "小部分的进行GC比大块的进行GC效率更高，消耗更少",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":3}",
      "blocks": [],
      "updated": 1687364898758
    },
    {
      "id": "15546ADF-E6B3-48F2-A4ED-4AF8BEF12C81",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "阶段1: Mark-Sweep 标记清除阶段，先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[23,17]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378058
    },
    {
      "id": "1597659E-474D-45A4-B912-0C31914CFDB7",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "问题记录",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687242378063
    },
    {
      "id": "1807B11E-D681-4A58-B92F-0623D1AA03B8",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Collect(Int32)",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378062
    },
    {
      "id": "1A53F38F-0EC9-4834-A8D5-86E55CB57472",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "The garbage collector is a common language runtime component that controls the allocation and release of managed memory。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378056,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"highlightColor\":\"#f3aa00 #ff8272;#e43e29 #ffd87d;g\",\"isBold\":false,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[0,120]}],\"color\":\"#00ca85 #00ffb9\",\"decorationStyles\":{},\"decorations\":{\"focus\":1},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"caption\"}",
      "blocks": [],
      "updated": 1749382756998
    },
    {
      "id": "1A54C5E4-F8DE-4526-8804-F4F186160DC4",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "第 1 代：这一代包含短期对象，并作为短期对象和长期对象之间的缓冲区。在垃圾收集器执行第 0代的收集后，它会压缩可访问对象的内存并将它们提升到第 1代。因为在收集中幸存下来的对象往往具有更长的生命周期，所以将它们提升到更高的代是有意义的。垃圾收集器不必在每次执行第 0代收集时重新检查第 1 代和第 2 代中的对象。 如果第 0 代的集合没有为应用程序回收足够的内存来创建新对象，则垃圾收集器可以执行第1 代的收集，然后是第 2 代。第 1 代中在集合中幸存下来的对象将被提升到第 2 代。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[0,5]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378060
    },
    {
      "id": "1B2DBC67-ED5F-4880-8073-15B8B8482B92",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "垃圾回收背后有这样一个基本的观念：编程语言(大多数的)似乎总能访问无限的内存。而开发者可以一直分配、分配再分配——像魔法一样，取之不尽用之不竭。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378063
    },
    {
      "id": "1CE8CB92-BBFD-4171-A5C2-9A0E4A8A0BC9",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPaVrWsT6y3rfrZNuVfPzdaHH7mNhUNgmyvNc4KqUpHGA98EHXWttEJPto3Gk2WnEer6oy4CgAXFHa7GGbHoxsxtNDvARUyMKWjX5r7ZmCUdwYXVkvntEaR53SGuFarzP2T4ttoBtRsdiRtwV4DUtzffYKh",
      "pageStyleData": "{}",
      "rawProperties": "{\"aspectRatio\":\"0.5015923566878981\",\"fileExtension\":\"tiff\",\"fileName\":\"Image.tiff\",\"isPreviewImageUploaded\":\"true\",\"mimeType\":\"image/tiff\",\"previewImageWidth\":\"315.0\",\"primaryColor\":\"16777215\",\"rawDataSize\":\"597738\",\"rawUrl\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPaVrWsT6y3rfrZNuVfPzdaHH7mNhUNgmyvNc4KqUpHGA98EHXWttEJPto3Gk2WnEer6oy4CgAXFHa7GGbHoxsxtNDvARUyMKWjX5r7ZmCUdwYXVkvntEaR53SGuFarzP2T4ttoBtRsdiRtwV4DUtzffYKh/Image.jpg\",\"uploaded\":\"true\",\"url\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyij2hXZ9ktkCSwi5dEzpLycdYcUPUxzquMxAw2pdw5Duzpitjm4Dce8eHE3GhyKrmZB6dwpSeUHxM9iQaixPaycZu6oEeRebGtxFU6qxfXKQonqMMoiyHvufmKikJKY2aB1SA336iPygVhDfXmsPgiRgtHSofEymyMPms1Fni64p4rJNxESsTUdjjVEswiVSdJmKz6FfMmhaVLPEw4cg2PqHq84KuNrsiBsTzXFr3EdS7NKETx7T21CKNPv3An9VPSoNV6Z2/Image.jpg\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364612772,
      "type": "image",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"imageFillStyle\":\"scaleAspectFit\",\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687446651968
    },
    {
      "id": "1D981D35-C8DC-4D8E-B282-5A0883E60F40",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC注意事项",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687242378062
    },
    {
      "id": "1ED17AC4-BC39-41EF-9416-09DF8166EE85",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "简单地把.NET的GC算法看作Mark-Compact算法。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[15,12]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378058
    },
    {
      "id": "2072BD89-BB6D-4033-AB5D-EFAD3B9D773A",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "public class BaseResource : IDisposable\n{\n    // 指向外部非托管资源\n    private IntPtr handle;\n    // 此类使用的其它托管资源.\n    private Component Components;\n    // 跟踪是否调用.Dispose方法，标识位，控制垃圾收集器的行为\n    private bool disposed = false;\n\n    // 构造函数\n    public BaseResource()\n    {\n        // Insert appropriate constructor code here.\n    }\n\n    // 实现接口IDisposable.\n    // 不能声明为虚方法virtual.\n    // 子类不能重写这个方法.\n    public void Dispose()\n    {\n        Dispose(true);\n        // 离开终结队列Finalization queue\n        // 设置对象的阻止终结器代码\n        //\n        GC.SuppressFinalize(this);\n    }\n\n    // Dispose(bool disposing) 执行分两种不同的情况.\n    // 如果disposing 等于 true, 方法已经被调用\n    // 或者间接被用户代码调用. 托管和非托管的代码都能被释放\n    // 如果disposing 等于false, 方法已经被终结器 finalizer 从内部调用过，\n    //你就不能在引用其他对象，只有非托管资源可以被释放。\n    protected virtual void Dispose(bool disposing)\n    {\n        // 检查Dispose 是否被调用过.\n        if (!this.disposed)\n        {\n            // 如果等于true, 释放所有托管和非托管资源\n            if (disposing)\n            {\n                // 释放托管资源.\n                Components.Dispose();\n            }\n            // 释放非托管资源，如果disposing为 false,\n            // 只会执行下面的代码.\n            CloseHandle(handle);\n            handle = IntPtr.Zero;\n            // 注意这里是非线程安全的.\n            // 在托管资源释放以后可以启动其它线程销毁对象，\n            // 但是在disposed标记设置为true前\n            // 如果线程安全是必须的，客户端必须实现。\n\n        }\n        disposed = true;\n    }\n    // 使用interop 调用方法\n    // 清除非托管资源.\n    [System.Runtime.InteropServices.DllImport(\"Kernel32\")]\n    private extern static Boolean CloseHandle(IntPtr handle);\n\n    // 使用C# 析构函数来实现终结器代码\n    // 这个只在Dispose方法没被调用的前提下，才能调用执行。\n    // 如果你给基类终结的机会.\n    // 不要给子类提供析构函数.\n    ~BaseResource()\n    {\n        // 不要重复创建清理的代码.\n        // 基于可靠性和可维护性考虑，调用Dispose(false) 是最佳的方式\n        Dispose(false);\n    }\n\n    // 允许你多次调用Dispose方法,\n    // 但是会抛出异常如果对象已经释放。\n    // 不论你什么时间处理对象都会核查对象的是否释放,\n    // check to see if it has been disposed.\n    public void DoSomething()\n    {\n        if (this.disposed)\n        {\n            throw new ObjectDisposedException();\n        }\n    }\n\n\n    // 不要设置方法为virtual.\n    // 继承类不允许重写这个方法\n    public void Close()\n    {\n        // 无参数调用Dispose参数.\n        Dispose();\n    }\n\n    public static void Main()\n    {\n        // Insert code here to create\n        // and use a BaseResource object.\n    }\n}",
      "rawProperties": "{\"language\":\"cs\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "code",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "pluginData": "{\"horizontalSizeClass\":\"regular\",\"pluginConfigurationData\":\"{\\\"themeId\\\":\\\"auto\\\"}\",\"pluginName\":\"codeBlock\",\"surfaceShadowOpacity\":0,\"verticalSizeClass\":\"regular\"}",
      "updated": 1687269159109
    },
    {
      "id": "24B5F2FE-4BE5-44D8-9DDB-B4A1CB6DE729",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Collect(Int32, GCCollectionMode)",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378062
    },
    {
      "id": "285ABDC7-51F2-4F48-A6B8-DA27EAEA1213",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "第0代时幸存的对象变成第1代，那么有没有可能这个时候第0代幸存对象的空间算到第1代，导致第1代满了呢？",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":1}",
      "blocks": [],
      "updated": 1687242378063
    },
    {
      "id": "2C65E5B1-C2D3-4359-9D46-2D9535A592FF",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "强制对零代到指定代进行即时垃圾回收。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378062
    },
    {
      "id": "2ED4396C-CE5D-4241-B9B9-5C6F0ECAC2F5",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "如果应用程序在第 0 代已满时尝试创建新对象，垃圾收集器将执行收集以尝试释放对象的地址空间。垃圾收集器首先检查第 0代中的对象，而不是托管堆中的所有对象。单独的第 0 代集合通常会回收足够的内存，使应用程序能够继续创建新对象。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"highlightColor\":\"#ff7100 #ff6656;#f300ad #ff87b2;g\",\"isBold\":false,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[46,31]},{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[46,31]}],\"decorationStyles\":{},\"decorations\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1749108208489
    },
    {
      "id": "322503A5-839A-4522-9350-92DFBF188F80",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "在GC被启动以后，经过Mark阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被Finalization Queue中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到Freachable Queue中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？因为这个对象的Finalize方法还没有被执行，所以不能让它死去。Freachable Queue平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的Finalize方法执行，之后将这个指针从队列中剔除，这时对象就可以安静的死去了。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[34,109]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378060
    },
    {
      "id": "3461B9B9-42AA-4980-8D58-C2A7C9C4A755",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": ".NET Framework的System.GC类提供了控制Finalize的两个方法：ReRegisterForFinalize和SuppressFinalize。前者是请求系统完成对象的Finalize方法，后者是请求系统不要完成对象的Finalize方法。ReRegisterForFinalize方法其实就是将指向对象的指针重新添加到Finalization Queue中。这就出现了一个很有趣的现象，因为在Finalization Queue中的对象可以复生，如果在对象的Finalize方法中调用ReRegisterForFinalize方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[0,83]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364847890
    },
    {
      "id": "359FDC73-7691-4691-A61A-E64EEA763CDD",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Debug和release执行模式之间稍有区别，release模式下后续代码没有引用的对象是unreachable的，而debug模式下需要等到当前函数执行完毕，这些对象才会成为unreachable，目的是为了调试时跟踪局部对象的内容。传给了COM+的托管对象也会成为root，并且具有一个引用计数器以兼容COM+的内存管理机制，引用计数器为0时，这些对象才可能成为被回收对象。Pinned objects指分配之后不能移动位置的对象，例如传递给非托管代码的对象（或者使用了fixed关键字），GC在指针修复时无法修改非托管代码中的引用指针，因此将这些对象移动将发生异常。pinned objects会导致heap出现碎片，但大部分情况来说传给非托管代码的对象应当在GC时能够被回收掉。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[0,23]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378059
    },
    {
      "id": "35E75F0F-3DA8-4D4B-A32C-F31A1C1B5918",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Finalization Queue和Freachable Queue",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687365476646
    },
    {
      "id": "3715B939-81D4-4081-8063-8C5940A6F57E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": ".Net中利用栈来完成检测并标记对象引用，在不断的入栈与出栈中完成检测：先在树图中选择一个需要检测的对象，将该对象的所有引用压栈，如此反复直到栈变空为止。栈变空意味着已经遍历了这个局部根能够到达的所有对象。树图节点范围包括局部变量、寄存器、静态变量，这些元素都要重复这个操作。一旦完成，便逐个对象地检查内存，没有标记的对象变成了垃圾。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorationStyles\":{},\"decorations\":{},\"indentationLevel\":1,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1749107768891
    },
    {
      "id": "3C733AF3-B1AE-43C1-ACB8-C754DD49C615",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "官网中有这么一句话：",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378056,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378056
    },
    {
      "id": "3EBF463A-56E7-46A1-AE65-D4E682E1A5AD",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Table",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "table",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [
        "ACB71FF1-9BFC-4976-9A38-4434670B6B05",
        "AABD05EA-3F73-4F65-820A-340A69DED518",
        "8F64AA89-59E4-486E-92D9-7512348052DC",
        "45381021-9701-4778-A70F-F71F403491F4",
        "1807B11E-D681-4A58-B92F-0623D1AA03B8",
        "2C65E5B1-C2D3-4359-9D46-2D9535A592FF",
        "24B5F2FE-4BE5-44D8-9DDB-B4A1CB6DE729",
        "D3B59173-E564-4A87-AE84-199A01BD5A35"
      ],
      "pluginData": "{\"cells\":[{\"rowId\":\"68344E33-6390-4D98-B12B-E8D77A8699F8\",\"id\":\"826B67E7-C2EC-478B-9D9E-64A1537F4326\",\"blockId\":\"ACB71FF1-9BFC-4976-9A38-4434670B6B05\",\"columnId\":\"681AF242-A67A-42EE-88E0-CA630FEC11C3\",\"style\":{\"backgroundColor\":\"#ff920070 #ff920080\",\"blockStyleModifiers\":\"align::center\"}},{\"rowId\":\"68344E33-6390-4D98-B12B-E8D77A8699F8\",\"id\":\"861FCBB0-A9E1-40C0-8068-A85281EA3EB5\",\"blockId\":\"AABD05EA-3F73-4F65-820A-340A69DED518\",\"columnId\":\"11FA1561-C8CE-4B5E-9832-3D9645568C64\",\"style\":{\"backgroundColor\":\"#ff920070 #ff920080\",\"blockStyleModifiers\":\"align::center\"}},{\"rowId\":\"A1FFC30C-2432-47E6-B11F-DCCF943AD812\",\"id\":\"A0FEEDEA-28A0-4584-9DD2-5AD4D28E9D4C\",\"blockId\":\"8F64AA89-59E4-486E-92D9-7512348052DC\",\"columnId\":\"681AF242-A67A-42EE-88E0-CA630FEC11C3\"},{\"rowId\":\"A1FFC30C-2432-47E6-B11F-DCCF943AD812\",\"id\":\"894691C2-093F-40B3-B745-3A359D3F3F64\",\"blockId\":\"45381021-9701-4778-A70F-F71F403491F4\",\"columnId\":\"11FA1561-C8CE-4B5E-9832-3D9645568C64\"},{\"rowId\":\"F85D11DB-6F54-451C-886E-9637E6318E22\",\"id\":\"19A8488D-E23B-486B-820A-C03A9F510EE4\",\"blockId\":\"1807B11E-D681-4A58-B92F-0623D1AA03B8\",\"columnId\":\"681AF242-A67A-42EE-88E0-CA630FEC11C3\"},{\"rowId\":\"F85D11DB-6F54-451C-886E-9637E6318E22\",\"id\":\"0D11E89A-820C-4861-8764-7CE63D4C1F10\",\"blockId\":\"2C65E5B1-C2D3-4359-9D46-2D9535A592FF\",\"columnId\":\"11FA1561-C8CE-4B5E-9832-3D9645568C64\"},{\"rowId\":\"2A35F7CE-8D18-4767-8FD3-72AE8E581724\",\"id\":\"809A7C0E-F59B-40F1-8C8F-09783673D2A6\",\"blockId\":\"24B5F2FE-4BE5-44D8-9DDB-B4A1CB6DE729\",\"columnId\":\"681AF242-A67A-42EE-88E0-CA630FEC11C3\"},{\"rowId\":\"2A35F7CE-8D18-4767-8FD3-72AE8E581724\",\"id\":\"34BE47C2-2185-4B8A-9E1E-030FA908682B\",\"blockId\":\"D3B59173-E564-4A87-AE84-199A01BD5A35\",\"columnId\":\"11FA1561-C8CE-4B5E-9832-3D9645568C64\"}],\"rows\":[{\"id\":\"68344E33-6390-4D98-B12B-E8D77A8699F8\"},{\"id\":\"A1FFC30C-2432-47E6-B11F-DCCF943AD812\"},{\"id\":\"F85D11DB-6F54-451C-886E-9637E6318E22\"},{\"id\":\"2A35F7CE-8D18-4767-8FD3-72AE8E581724\"}],\"columns\":[{\"id\":\"681AF242-A67A-42EE-88E0-CA630FEC11C3\"},{\"id\":\"11FA1561-C8CE-4B5E-9832-3D9645568C64\"}],\"style\":{\"hasColumnsHeader\":true}}",
      "updated": 1687364559921
    },
    {
      "id": "3EEC335B-D611-4D60-8B64-37B9C1342689",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "对于较大内存的对象，频繁的进行GC将耗费大量的资源，成本很高且效果较差",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":1}",
      "blocks": [],
      "updated": 1687364898755
    },
    {
      "id": "3F58BA28-0A0E-4059-B4E5-689BC82B0890",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPLaoR89xGoa73fqpvaRVgYoAPeFuc6HuQpRq8c9TTx1Q7dVNAxwNmFXRuvjno6C4vULh33AynMNVvzj4SDbaTZ6Ex9rqKi5ab3ctssutYCdXo5j7d1kLgRNDSWpNKuddnWa3AwkNZiAG2GYjSYTbuH7sz5",
      "pageStyleData": "{}",
      "rawProperties": "{\"aspectRatio\":\"3.7365269461077846\",\"fileExtension\":\"tiff\",\"fileName\":\"Image.tiff\",\"isPreviewImageUploaded\":\"true\",\"mimeType\":\"image/tiff\",\"previewImageWidth\":\"624.0\",\"primaryColor\":\"16777215\",\"rawDataSize\":\"316886\",\"rawUrl\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPLaoR89xGoa73fqpvaRVgYoAPeFuc6HuQpRq8c9TTx1Q7dVNAxwNmFXRuvjno6C4vULh33AynMNVvzj4SDbaTZ6Ex9rqKi5ab3ctssutYCdXo5j7d1kLgRNDSWpNKuddnWa3AwkNZiAG2GYjSYTbuH7sz5/Image.jpg\",\"uploaded\":\"true\",\"url\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyij2hXZ9ktkCSwi5dEzpLycdYcUPUxzquMxAw2pdw5Duzpitjm4Dce8eHE3GhyKrmZB6dwpSeUHxM9iQaixPaycZu6oEeRebGtxFU6qxfXKQonpzUaHU1WZpaMaj3YteUwBMT4rpcu35MGSWJVcAY6H7bDoAstc8gJsNgg1xwzR8hpyzvk8vikKbhvN4QTd1oZnsZM91ZMWBKEFwbAEgoka2DjxsFJjsD75VUQDmjrMV2mPvR2YgdWWT7vMDoxGgY4s9ek3x/Image.jpg\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364696745,
      "type": "image",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"imageFillStyle\":\"scaleAspectFit\",\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687446659481
    },
    {
      "id": "3FB390C1-1E8A-432D-8B6D-4032D3820721",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "答：不会，因为第0代和第1代的预算容量相差悬殊，而且不是在第1代空间完全满的时候才清理内存的，而是差不多快满的时候就会清理内存，这个“快满”的空间是大于第0代的预算容量的；",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378063
    },
    {
      "id": "43CAFA92-6FA3-480D-B254-F99488B4ABB5",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "概括：就是GC会帮你自动管理内存，分配内存，回收内存，采用的就是对应的GC的算法。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"color\":\"#0087ff #40a5ff\",\"decorationStyles\":{},\"decorations\":{\"block\":1},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"strong\"}",
      "blocks": [],
      "updated": 1749107865166
    },
    {
      "id": "4505BFCF-7308-4F52-BE77-0BFEDC3EDCC7",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "C#-垃圾回收机制(GC)【Area】",
      "pageStyleData": "{\"background\":{\"size\":\"full\",\"solidColor\":\"#f7f9f7\",\"type\":\"solid\"},\"isMirrored\":true,\"pageWidthType\":\"true\",\"styleId\":\"luki\"}",
      "rawProperties": "{\"coverImageBackgroundColor\":\"#ffffff\",\"coverImageEnabled\":\"false\",\"spellCheckEnabled\":\"false\",\"spellCheckLanguage\":\"en_US\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242160000,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorationStyles\":{},\"decorations\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"pageRegular\"}",
      "blocks": [
        "59E06339-0B72-4A3F-8087-8FACD48D45CC",
        "3C733AF3-B1AE-43C1-ACB8-C754DD49C615",
        "1A53F38F-0EC9-4834-A8D5-86E55CB57472",
        "9CE63877-C91E-406C-A7EA-939FC2F1F61B",
        "43CAFA92-6FA3-480D-B254-F99488B4ABB5",
        "06F053CF-DF52-4955-9F97-3A4A4B36A890",
        "6CEE1B0F-8EC8-49F4-A5B4-19D6496F8818",
        "B8CF178E-1241-4721-A76A-D26EC8DB3B6E",
        "4DAE559F-3261-4DF4-9847-54811A06D9C4",
        "1CE8CB92-BBFD-4171-A5C2-9A0E4A8A0BC9",
        "E1DCEF38-8F07-4E2B-A44D-CE0E49206CF1",
        "8EC4B506-E291-4D7A-B9A7-75D79586BE93",
        "7B38B74B-ACC0-4FF8-A5BC-F906F6E43E38",
        "70CF3801-ABA0-4297-9E61-BBC289C9AC63",
        "B2FDB06D-4DD5-44F2-97BE-639F18D28821",
        "6A907661-641D-4FB5-96AC-4DFFD3064544",
        "3715B939-81D4-4081-8063-8C5940A6F57E",
        "0A3E7500-1021-48EE-9067-A3F8302574BB",
        "B7EA2416-495C-4E15-942D-1FC8AA240995",
        "1ED17AC4-BC39-41EF-9416-09DF8166EE85",
        "15546ADF-E6B3-48F2-A4ED-4AF8BEF12C81",
        "5EE472B6-A55B-4F3F-8026-6A913C0F1A7D",
        "F3470433-A7CD-4D13-88ED-B2A57F72E80E",
        "F25215C1-12D2-4315-B432-5D98BF9DA8EA",
        "CFDA062E-FA6A-480B-9486-1A81B4F5BD9D",
        "91820D37-81B8-4A75-ADC9-A9281C41D368",
        "8CA8FE36-4544-4551-BD5C-0FE1B61709CD",
        "76C1E5CF-45A0-4E4F-B382-7DEA0D2AAC7E",
        "9B64F9AC-C1B7-4A84-9CD8-F0C0B93F077A",
        "5C635EAE-0CAF-46EA-9444-6C5CB1DC07D2",
        "359FDC73-7691-4691-A61A-E64EEA763CDD",
        "9699A820-C8AF-405B-BF75-99A20F9CEFBF",
        "7E23B3DC-527A-40FC-9BF7-F49DF3A978FA",
        "3EEC335B-D611-4D60-8B64-37B9C1342689",
        "F274C25A-47A4-4180-86AD-9647FD9E0B8C",
        "14092947-B68C-47EC-ABE5-58D3AD6480FD",
        "A3BCC23D-69BA-4E95-A3C7-8B70CAF6A571",
        "86FD1AA7-0EE1-49D1-8AB3-5B88A4A57747",
        "3F58BA28-0A0E-4059-B4E5-689BC82B0890",
        "0F4873AD-D49C-4EFE-A084-FA23D8133B85",
        "E5FE4302-EE46-46FE-9990-5112D5DC152D",
        "2ED4396C-CE5D-4241-B9B9-5C6F0ECAC2F5",
        "1A54C5E4-F8DE-4526-8804-F4F186160DC4",
        "4DD38256-87F5-454B-8AC8-E4E972392D87",
        "D374A75B-9DC1-40FC-826B-6CAD81A1FA2B",
        "A9AAB5ED-03DF-4B08-B9D9-2BC227BE073D",
        "35E75F0F-3DA8-4D4B-A32C-F31A1C1B5918",
        "A2107879-7D87-4C05-A426-9E14A819B26E",
        "322503A5-839A-4522-9350-92DFBF188F80",
        "3461B9B9-42AA-4980-8D58-C2A7C9C4A755",
        "069FA684-867D-4B29-8EED-D00F0844C9B8",
        "7FF40F28-724E-45DD-86A9-5FED2D0DDA2E",
        "9BFAD3D8-FB63-4AC7-B364-5F2E46B2A6C7",
        "BBF11161-B4C8-4F35-A0DF-8A4D036FC9A9",
        "E4F0A612-9517-4EC0-B23F-7D306D06137C",
        "0F20F320-D619-44C1-8721-9940A72AED5A",
        "99390115-C4FD-477B-8BFB-7DC17529DFC5",
        "2072BD89-BB6D-4033-AB5D-EFAD3B9D773A",
        "94AE102E-B874-4806-B9A5-AFCDFF2A1B1F",
        "808B317A-9D0B-44C6-92EB-E8D1F910C167",
        "78819967-0818-4CF2-A5E3-D9CAFCB9E64E",
        "3EBF463A-56E7-46A1-AE65-D4E682E1A5AD",
        "1D981D35-C8DC-4D8E-B282-5A0883E60F40",
        "ADEB0454-80E4-4A49-862F-516BA2FDB481",
        "819CC221-5A06-4098-B1F7-90BE4D40D5E3",
        "4D6A8D39-1FD9-405D-8BBC-206B7E90B0DA",
        "6E8306AA-A5F0-401A-9CFB-5F4ED01DE243",
        "66497B4C-0198-4824-8766-0F9CE11A6A80",
        "BF9326C5-672C-4796-BBAB-7B0A5B5DD04F",
        "958BF689-87E5-4DCA-BD22-0D2DACACAE44",
        "B601DAFA-C337-471D-91DF-282CAC236067",
        "A3CD0990-B8DC-4DDA-94B0-A470A17386A6",
        "50A3B44D-1CCB-4D11-80DE-20F3A3B5557E",
        "6D9120A9-83E6-4F81-8417-29E8D3D16EB9",
        "1B2DBC67-ED5F-4880-8073-15B8B8482B92",
        "B2DE13E9-A413-4186-89BF-6D61201F60ED",
        "1597659E-474D-45A4-B912-0C31914CFDB7",
        "285ABDC7-51F2-4F48-A6B8-DA27EAEA1213",
        "3FB390C1-1E8A-432D-8B6D-4032D3820721",
        "62D34C30-2B17-42F1-A68C-6D23EA8055E9",
        "78D088A0-6CED-43B3-86C7-27C76E7D13F7",
        "498977D2-5394-4D04-A0B2-5BEC4DFC6AAE",
        "D6FB468F-4501-49EE-94A7-B9924FC2EC4B"
      ],
      "pageStyleProps": "{\"color\":\"#1F2225 #F4F4F4\",\"backdrop\":\"#f7f9f7 #f7f9f7\",\"theme-id\":\"3C07060B-6733-42A8-B033-C8EC0A19272D\",\"card-assets\":\"none\",\"font-family\":\"system\",\"page-width-type\":\"true\",\"separator-style\":\"line\",\"background-color\":\"#FFFFFF #222222\"}",
      "updated": 1750335506430
    },
    {
      "id": "45381021-9701-4778-A70F-F71F403491F4",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "强制对所有代进行即时垃圾回收。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378062
    },
    {
      "id": "498977D2-5394-4D04-A0B2-5BEC4DFC6AAE",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "答：同步块索引的功能很多，即可以标记同步位，又可以标记可达，还可以存储哈希码",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378064,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378064
    },
    {
      "id": "4D6A8D39-1FD9-405D-8BBC-206B7E90B0DA",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":3}",
      "blocks": [],
      "updated": 1687364942658
    },
    {
      "id": "4DAE559F-3261-4DF4-9847-54811A06D9C4",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "访问资源所需要的步骤有：",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378057
    },
    {
      "id": "4DD38256-87F5-454B-8AC8-E4E972392D87",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "第 2 代：这一代包含长期存在的对象。长寿命对象的一个示例是服务器应用程序中的对象，其中包含在进程持续期间有效的静态数据。在集合中存活的第 2 代对象将保留在第 2 代中，直到它们被确定在未来的集合中不可访问。 大对象堆（有时称为第3 代）上的对象也在第 2代中收集。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[0,5]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378060
    },
    {
      "id": "50A3B44D-1CCB-4D11-80DE-20F3A3B5557E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC对不同代的对象执行不同的检查策略以优化性能。每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize，就变成第2代对象，从而在内存中停留更长时间。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":10}",
      "blocks": [],
      "updated": 1687364942665
    },
    {
      "id": "59E06339-0B72-4A3F-8087-8FACD48D45CC",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "什么是GC",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378056,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorationStyles\":{},\"decorations\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1748954165370
    },
    {
      "id": "5C635EAE-0CAF-46EA-9444-6C5CB1DC07D2",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "指针修复是因为compact过程移动了heap对象，对象地址发生变化，需要修复所有引用指针，包括stack、CPU register中的指针以及heap中其他对象的引用指针。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378059
    },
    {
      "id": "5EE472B6-A55B-4F3F-8026-6A913C0F1A7D",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "阶段2: Compact 压缩阶段，对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。Heap内存经过回收、压缩之后，可以继续采用前面的heap内存分配方法，即仅用一个指针记录heap分配的起始地址就可以。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378058
    },
    {
      "id": "62D34C30-2B17-42F1-A68C-6D23EA8055E9",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyij2hXZ9ktkCSwi5dEzpLycdYcUPUxzquMxAw2pdw5Duzpitjm4Dce8eHE3GhyKrmZB6dwpSeUHxM9iQaixPaycZu6oEeRebGtxFU6qxfXKQonptkYLxh8qyq82vvfamoi7A581dHHBRuqWKMiAac8AZignP9zhskUCLtaZm1fnXXe4ttzS214jVbShW5WvFookDhjRoKbwysXK2GkN1DrFSkhmTAoJztxxHaiAAynF28TiqEMsyn62TugBBcnyobaDmNxC3",
      "rawProperties": "{\"aspectRatio\":\"2.3506493506493507\",\"fileExtension\":\"tiff\",\"fileName\":\"Image.tiff\",\"isPreviewImageUploaded\":\"true\",\"mimeType\":\"image/tiff\",\"previewImageWidth\":\"362.0\",\"primaryColor\":\"16777215\",\"rawDataSize\":\"170610\",\"rawUrl\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPdjzS4YcasjkmebcryjEWao3XLdXga4YfByCYCowuz5kZGvFcyL1TrJZ4yAWuFerGNrYRBVzzp84krzcGamXDWbewZiieRc2YycXyFRMHebAqzFWww3UJ1UAtXFDKo2RuWW4P7bw7d2dcxYvUBokooVscf/Image.jpg\",\"uploaded\":\"true\",\"url\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyij2hXZ9ktkCSwi5dEzpLycdYcUPUxzquMxAw2pdw5Duzpitjm4Dce8eHE3GhyKrmZB6dwpSeUHxM9iQaixPaycZu6oEeRebGtxFU6qxfXKQonptkYLxh8qyq82vvfamoi7A581dHHBRuqWKMiAac8AZignP9zhskUCLtaZm1fnXXe4ttzS214jVbShW5WvFookDhjRoKbwysXK2GkN1DrFSkhmTAoJztxxHaiAAynF28TiqEMsyn62TugBBcnyobaDmNxC3/Image.jpg\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1748951898755,
      "type": "image",
      "style": "{\"decorationStyles\":{},\"decorations\":{},\"imageFillStyle\":\"scaleAspectFit\",\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1748951902333
    },
    {
      "id": "66497B4C-0198-4824-8766-0F9CE11A6A80",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC每次运行时会压缩托管堆。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":5}",
      "blocks": [],
      "updated": 1687364942661
    },
    {
      "id": "6A907661-641D-4FB5-96AC-4DFFD3064544",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "“标记”本领——垃圾的识别：从应用程序的root出发，利用相互引用关系，遍历其在Heap上动态分配的所有对象，没有被引用的对象不被标记，即成为垃圾；存活的对象被标记，即维护成了一张“根-对象可达图”。其实，CLR会把对象关系看做“树图”，这样会加快遍历对象的速度。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[1,2]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"bullet\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378058
    },
    {
      "id": "6CEE1B0F-8EC8-49F4-A5B4-19D6496F8818",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC产生的背景",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687242378057
    },
    {
      "id": "6D9120A9-83E6-4F81-8417-29E8D3D16EB9",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "总结",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687242378063
    },
    {
      "id": "6E8306AA-A5F0-401A-9CFB-5F4ED01DE243",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC在一个独立的线程中运行来删除不再被引用的内存。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":4}",
      "blocks": [],
      "updated": 1687364942660
    },
    {
      "id": "70CF3801-ABA0-4297-9E61-BBC289C9AC63",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "以应用程序的root为基础，遍历应用程序在Heap上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是已经死亡的、哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，需要被回收。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"color\":\"#0064ff #0094ff\",\"decorationStyles\":{},\"decorations\":{\"block\":1},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1749107713294
    },
    {
      "id": "76C1E5CF-45A0-4E4F-B382-7DEA0D2AAC7E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPXwx4uWRgW4M89wd5b8BTaLnWr1E2JPoWsngbGvLXJNWDKV8tGqqkPAvSZtSQ7GDk195ab5T4XqxzAidNPW7CEzKS8MiM6suLnWG9cgWeaQ7KtQpWwpgArAijTuNedUsvMaxupSTg4NikkbgUPbDkJvRf6",
      "pageStyleData": "{}",
      "rawProperties": "{\"aspectRatio\":\"1.1721854304635762\",\"fileExtension\":\"tiff\",\"fileName\":\"Image.tiff\",\"isPreviewImageUploaded\":\"true\",\"mimeType\":\"image/tiff\",\"previewImageWidth\":\"531.0\",\"primaryColor\":\"16777215\",\"rawDataSize\":\"725916\",\"rawUrl\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DPXwx4uWRgW4M89wd5b8BTaLnWr1E2JPoWsngbGvLXJNWDKV8tGqqkPAvSZtSQ7GDk195ab5T4XqxzAidNPW7CEzKS8MiM6suLnWG9cgWeaQ7KtQpWwpgArAijTuNedUsvMaxupSTg4NikkbgUPbDkJvRf6/Image.jpg\",\"uploaded\":\"true\",\"url\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyij2hXZ9ktkCSwi5dEzpLycdYcUPUxzquMxAw2pdw5Duzpitjm4Dce8eHE3GhyKrmZB6dwpSeUHxM9iQaixPaycZu6oEeRebGtxFU6qxfXKQonpyAERwRN6vGmAx9zfMWXxjv1TevTrxtvdvaktGyGmjoEbj68GyNcGcHigoybUqBUd1kHug3M9oxrqC9HkBR9fraypztSnoGpSdA1KsX11dqJXobeFi3wxPM6nVi4euoTbzPgshzqb6efaPV29Jxb7PpF1G/Image.jpg\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364665414,
      "type": "image",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"imageFillStyle\":\"scaleAspectFit\",\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687446658361
    },
    {
      "id": "78819967-0818-4CF2-A5E3-D9CAFCB9E64E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC的方法：",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378061
    },
    {
      "id": "78D088A0-6CED-43B3-86C7-27C76E7D13F7",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "同步块索引，你刚刚说又可以锁住对象标记同步，又可以用来标记可达？",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378064,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":2}",
      "blocks": [],
      "updated": 1687364954676
    },
    {
      "id": "7B38B74B-ACC0-4FF8-A5BC-F906F6E43E38",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "垃圾收集器的本质,就是跟踪所有被引用到的对象，整理不再被引用的对象，回收相应的内存。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"color\":\"#0064ff #0094ff\",\"decorationStyles\":{},\"decorations\":{\"block\":1},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1749107713293
    },
    {
      "id": "7E23B3DC-527A-40FC-9BF7-F49DF3A978FA",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC算法的设计考虑到了4个因素：",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[0,16]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364884639
    },
    {
      "id": "7FF40F28-724E-45DD-86A9-5FED2D0DDA2E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC并不是能释放所有的资源。它不能自动释放非托管资源。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":1}",
      "blocks": [],
      "updated": 1687364922101
    },
    {
      "id": "808B317A-9D0B-44C6-92EB-E8D1F910C167",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "作用：强制进行垃圾回收。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378061
    },
    {
      "id": "819CC221-5A06-4098-B1F7-90BE4D40D5E3",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "循环引用，网状结构等的实现会变得简单。GC的标志-压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":2}",
      "blocks": [],
      "updated": 1687364942656
    },
    {
      "id": "86FD1AA7-0EE1-49D1-8AB3-5B88A4A57747",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "基于此，按照寿命长短，托管堆被分为了三个年龄层，分别是Generation 0，Generation 1， Generation 2。垃圾收集器在第 0 代存储新对象。在应用程序生命周期早期创建的在收集过程中幸存下来的对象被提升并存储在第 1 代和第 2 代中。因为压缩托管堆的一部分比压缩整个堆要快，因此该方案允许垃圾收集器在特定代中释放内存，而不是在每次执行收集时释放整个托管堆的内存。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378060
    },
    {
      "id": "8CA8FE36-4544-4551-BD5C-0FE1B61709CD",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Reachable objects：指根据对象引用关系，从roots出发可以到达的对象。例如当前执行函数的局部变量对象A是一个root object，他的成员变量引用了对象B，则B是一个reachable object。从roots出发可以创建reachable objects graph，剩余对象即为unreachable，可以被回收 。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[0,17]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378059
    },
    {
      "id": "8EC4B506-E291-4D7A-B9A7-75D79586BE93",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC工作原理",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687242378057
    },
    {
      "id": "8F64AA89-59E4-486E-92D9-7512348052DC",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Collect()",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378062
    },
    {
      "id": "91820D37-81B8-4A75-ADC9-A9281C41D368",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针（还有finalization queue）等。主要可以归为2种类型：已经初始化了的静态变量、线程仍在使用的对象（stack+CPU register） 。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[14,4]},{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[19,4]},{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[24,4]},{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[29,6]},{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[36,37]},{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[92,4]},{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[97,29]}],\"decorationStyles\":{},\"decorations\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1749108098361
    },
    {
      "id": "94AE102E-B874-4806-B9A5-AFCDFF2A1B1F",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC.Collect() 方法",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[0,15]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378061
    },
    {
      "id": "958BF689-87E5-4DCA-BD22-0D2DACACAE44",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":7}",
      "blocks": [],
      "updated": 1687364942662
    },
    {
      "id": "9699A820-C8AF-405B-BF75-99A20F9CEFBF",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Generational 分代算法",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"title\"}",
      "blocks": [],
      "updated": 1687242378059
    },
    {
      "id": "99390115-C4FD-477B-8BFB-7DC17529DFC5",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "当你用Dispose方法释放未托管对象的时候，应该调用GC.SuppressFinalize。如果对象正在终结队列(finalization queue), GC.SuppressFinalize会阻止GC调用Finalize方法。因为Finalize方法的调用会牺牲部分性能。如果你的Dispose方法已经对委托管资源作了清理，就没必要让GC再调用对象的Finalize方法(MSDN)。附上MSDN的代码，大家可以参考。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378061
    },
    {
      "id": "9B64F9AC-C1B7-4A84-9CD8-F0C0B93F077A",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364664901,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364664901
    },
    {
      "id": "9BFAD3D8-FB63-4AC7-B364-5F2E46B2A6C7",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":2}",
      "blocks": [],
      "updated": 1687364922103
    },
    {
      "id": "9CE63877-C91E-406C-A7EA-939FC2F1F61B",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "垃圾回收机制（Garbage Collection）简称GC，是CLR的一个组件，它控制内存的分配与释放。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378056,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[6,20]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242992616
    },
    {
      "id": "A2107879-7D87-4C05-A426-9E14A819B26E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "这两个队列和.NET对象所提供的Finalize方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[29,31]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364805954
    },
    {
      "id": "A3BCC23D-69BA-4E95-A3C7-8B70CAF6A571",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "新创建的对象在内存分配上多为连续，且关联程度较强，关联度较强有利于CPU Cache命中。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":4}",
      "blocks": [],
      "updated": 1687364898759
    },
    {
      "id": "A3CD0990-B8DC-4DDA-94B0-A470A17386A6",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "NET GC使用\"代\"(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。成员变量和全局变量很快变成第1代对象并最终成为第2代对象。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":9}",
      "blocks": [],
      "updated": 1687364942664
    },
    {
      "id": "A9AAB5ED-03DF-4B08-B9D9-2BC227BE073D",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "当垃圾收集器检测到某一代存活率较高时，会增加该代的分配阈值。 下一个集合获得大量回收内存。 CLR 不断平衡两个优先级：不让应用程序的工作集因延迟垃圾收集而变得太大，以及不让垃圾收集运行得太频繁。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378060
    },
    {
      "id": "AABD05EA-3F73-4F65-820A-340A69DED518",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "说明",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"alignmentStyle\":\"center\",\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364559920
    },
    {
      "id": "ACB71FF1-9BFC-4976-9A38-4434670B6B05",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "名称",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"alignmentStyle\":\"center\",\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364559919
    },
    {
      "id": "ADEB0454-80E4-4A49-862F-516BA2FDB481",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":1}",
      "blocks": [],
      "updated": 1687364942655
    },
    {
      "id": "B2DE13E9-A413-4186-89BF-6D61201F60ED",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC的基本工作原理是：通过最基本的标记清除原理，清除不可达对象；再像磁盘碎片整理一样压缩、整理可用内存；最后通过分代算法实现性能最优化。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378063
    },
    {
      "id": "B2FDB06D-4DD5-44F2-97BE-639F18D28821",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "垃圾回收的算法有有多种，在.Net中采用了一种叫做“标记与清除(Mark-Sweep)”算法，该算法分两个本领：",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[26,17]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378057
    },
    {
      "id": "B601DAFA-C337-471D-91DF-282CAC236067",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer，不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer，而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":8}",
      "blocks": [],
      "updated": 1687364942663
    },
    {
      "id": "B7EA2416-495C-4E15-942D-1FC8AA240995",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "Compact算法除了会提高再次分配内存的速度，如果新分配的对象在堆中位置很紧凑的话，高速缓存的性能将会得到提高，因为一起分配的对象经常被一起使用(程序的局部性原理)，所以为程序提供一段连续空白的内存空间是很重要的。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorationStyles\":{},\"decorations\":{\"focus\":1},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"caption\"}",
      "blocks": [],
      "updated": 1749107789174
    },
    {
      "id": "B8CF178E-1241-4721-A76A-D26EC8DB3B6E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "每个程序都要使用这样或那样的资源，比如文件、内存缓冲区、屏幕空间、网络连接、数据库资源等。在面向对象的环境中，每个类型都代表可供程序使用的一种资源。要使用这些资源，必须为代表资源的类型分配内存。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378057
    },
    {
      "id": "BBF11161-B4C8-4F35-A0DF-8A4D036FC9A9",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。使用using语句可以简化资源管理。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378061
    },
    {
      "id": "BF9326C5-672C-4796-BBAB-7B0A5B5DD04F",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378063,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":6}",
      "blocks": [],
      "updated": 1687364942661
    },
    {
      "id": "CFDA062E-FA6A-480B-9486-1A81B4F5BD9D",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "主要处理步骤：将线程挂起→确定roots→创建reachable objects graph→对象回收→heap压缩→指针修复。可以这样理解roots：heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378058,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[7,5]},{\"isBold\":true,\"range\":[13,7]},{\"isBold\":true,\"range\":[21,25]},{\"isBold\":true,\"range\":[47,4]},{\"isBold\":true,\"range\":[52,6]},{\"isBold\":true,\"range\":[59,4]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378058
    },
    {
      "id": "D374A75B-9DC1-40FC-826B-6CAD81A1FA2B",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "当条件允许时，垃圾收集发生在特定的世代。收集一代意味着收集该一代及其所有年轻一代的对象。第 2 代垃圾回收也称为完整垃圾回收，因为它回收所有代中的对象（即托管堆中的所有对象）。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"isCode\":false,\"isItalic\":false,\"isStrikethrough\":false,\"range\":[20,24]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364779930
    },
    {
      "id": "D3B59173-E564-4A87-AE84-199A01BD5A35",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "强制在 GCCollectionMode 值所指定的时间对零代到指定代进行垃圾回收",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378062,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378062
    },
    {
      "id": "D6FB468F-4501-49EE-94A7-B9924FC2EC4B",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "https://blog.csdn.net/acmilanvanbasten/article/details/14521051 具体可以看看这篇文章，写的很详细。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378064,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"linkURL\":\"https://blog.csdn.net/acmilanvanbasten/article/details/14521051\",\"range\":[0,63]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378064
    },
    {
      "id": "E1DCEF38-8F07-4E2B-A44D-CE0E49206CF1",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "上述步骤如果最后一步是由程序员负责，可能会产生一些无法预测的问题，如忘记释放不再使用的内存、试图使用已被释放的内存（即野指针），这种bug会造成资源泄露（浪费内存）和对象损坏（影响稳定性）。而正确的进行资源管理通常很难而且很枯燥，它会极大的分散程序员的注意力。而GC能简化程序员的内存管理工作。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378057,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[131,2]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378057
    },
    {
      "id": "E4F0A612-9517-4EC0-B23F-7D306D06137C",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "示例：",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378061,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378061
    },
    {
      "id": "E5FE4302-EE46-46FE-9990-5112D5DC152D",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "第 0 代：这是最年轻的一代，包含生命周期很短的对象。短期对象的一个例子是临时变量。垃圾收集在这一代发生得最频繁。新分配的对象形成了第0代的对象，并且是隐式的第 0 代集合。但是，对象很大，它们将进入大对象堆 (LOH)，有时也称为第3 代。第3 代可以理解为物理代，作为第二代的衍生。 大多数对象在第 0 代被回收用于垃圾收集，并且不会存活到下一代。",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378060,
      "type": "text",
      "style": "{\"_runAttributes\":[{\"isBold\":true,\"range\":[0,5]}],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687242378060
    },
    {
      "id": "F25215C1-12D2-4315-B432-5D98BF9DA8EA",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364651845,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687364651845
    },
    {
      "id": "F274C25A-47A4-4180-86AD-9647FD9E0B8C",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "大量新创建的对象生命周期都较短，老对象的生命周期都较长",
      "rawProperties": "{}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687242378059,
      "type": "text",
      "style": "{\"_runAttributes\":[],\"decorations\":{\"focus\":1},\"decorationStyles\":{},\"indentationLevel\":0,\"listStyle\":\"numbered\",\"textStyle\":\"body\",\"userDefinedListNumber\":2}",
      "blocks": [],
      "updated": 1687364898756
    },
    {
      "id": "F3470433-A7CD-4D13-88ED-B2A57F72E80E",
      "documentId": "DD48EF9D-B6A3-4546-989E-9D9791A387C5",
      "content": "https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DQ1f7gAnpd2mns73h6RkFcAFfe5Zy23SrbD4tgujvmSx1wsYGbwMGDf5i8fdvLJjybjepuHbyb54WtCpjgrueFZFoJr3cPkA6u8FxZNu4RVmY2UJu1BCkkeLYyoGgh8pmN8oysHEXmcKh7GQzkLryiNoPoE",
      "pageStyleData": "{}",
      "rawProperties": "{\"aspectRatio\":\"3.3087248322147653\",\"fileExtension\":\"tiff\",\"fileName\":\"Image.tiff\",\"isPreviewImageUploaded\":\"true\",\"mimeType\":\"image/tiff\",\"previewImageWidth\":\"493.0\",\"primaryColor\":\"16777215\",\"rawDataSize\":\"224626\",\"rawUrl\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyjEhZRktEdGcdsWHUr2N7ptuDTyQVk6NphCnfGBtBKtpfzKZSkZQ6beYmuLKLt965kwTw2HHP756FRRX56AvVPrw1CX2EXR7QkZjT9bShEk66DQ1f7gAnpd2mns73h6RkFcAFfe5Zy23SrbD4tgujvmSx1wsYGbwMGDf5i8fdvLJjybjepuHbyb54WtCpjgrueFZFoJr3cPkA6u8FxZNu4RVmY2UJu1BCkkeLYyoGgh8pmN8oysHEXmcKh7GQzkLryiNoPoE/Image.jpg\",\"uploaded\":\"true\",\"url\":\"https://secure-res.craft.do/v2/XcxFsRQ4H9QDRiWvEDiyJxJ1u2o23p25F14XWCi9pjyij2hXZ9ktkCSwi5dEzpLycdYcUPUxzquMxAw2pdw5Duzpitjm4Dce8eHE3GhyKrmZB6dwpSeUHxM9iQaixPaycZu6oEeRebGtxFU6qxfXKQonqMEVRnoC7F4ASNG8jnHN236YLifjNJoUgvfw5EHo4PN7F87rFbyQVGmiC3hNuuJQrRbno6wRacnSsfQwD1MgVUMeZ5X5dc87qWTkVBSLwwka9348hDANGBCG1BfLvoq1nn64xT2Lxc499MdQfXeTgV9CqL/Image.jpg\"}",
      "createdByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "modifiedByUserId": "ff47392e-1b37-dd92-268a-2c80735d18e1",
      "created": 1687364653538,
      "type": "image",
      "style": "{\"_runAttributes\":[],\"decorations\":{},\"decorationStyles\":{},\"imageFillStyle\":\"scaleAspectFit\",\"indentationLevel\":0,\"listStyle\":\"none\",\"textStyle\":\"body\"}",
      "blocks": [],
      "updated": 1687446661368
    }
  ],
  "inheritedPageStyle": {
    "pageWidthType": "true",
    "background": {
      "size": "full",
      "solidColor": "#f7f9f7",
      "type": "solid"
    },
    "styleId": "luki",
    "header": {}
  },
  "inheritedPageStyleProps": {
    "color": "#1F2225 #F4F4F4",
    "backdrop": "#f7f9f7 #f7f9f7",
    "theme-id": "3C07060B-6733-42A8-B033-C8EC0A19272D",
    "card-assets": "none",
    "font-family": "system",
    "page-width-type": "true",
    "separator-style": "line",
    "background-color": "#FFFFFF #222222"
  },
  "rootBlockId": "4505BFCF-7308-4F52-BE77-0BFEDC3EDCC7",
  "settings": {
    "documentAppearance": "default",
    "hiddenLogo": false,
    "freeTier": false,
    "teamId": "e5336d46-6f5f-1acd-7266-4d0fefce8055",
    "forceSwitches": {}
  },
  "features": {
    "enabled": [
      "fs-show-title",
      "fs-enable-column-view"
    ],
    "disabled": [
      "fs-add-comment",
      "fs-view-comment",
      "fs-object-links",
      "fs-show-author",
      "fs-show-custom-logo",
      "fs-show-duplicate-as-template",
      "fs-hide-logo",
      "fs-hide-table-of-contents",
      "fs-hide-presentation-mode"
    ]
  }
}