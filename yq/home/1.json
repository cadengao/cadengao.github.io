[
  {
    "uuid": "54197715.119109318",
    "id": 119109318,
    "title": "C#-垃圾回收机制(GC)【Area】",
    "description": "什么是GC官网中有这么一句话：The garbage collector is a common language runtime component that controls the allocation and release of managed memory。垃圾回收机制（Garba...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 5795,
    "created_at": "2023-03-22T10:18:37",
    "updated_at": "2024-08-17T03:29:43"
  },
  {
    "uuid": "54197715.119110971",
    "id": 119110971,
    "title": "C#-资源类型(托管资源和非托管资源)【Area】",
    "description": "分为托管资源和非托管资源：托管资源指的是.NET可以自动进行回收的资源，主要是指托管堆上分配的内存资源。托管资源的回收工作是不需要人工干预的，由.NET运行库在合适时机调用垃圾回收器进行回收。非托管资源指的是.NET不知道如何回收的资源，最常见的一类非托管资源是包装操作系统资源的对象，例如：文...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 480,
    "created_at": "2023-03-22T10:30:50",
    "updated_at": "2024-08-20T07:17:36"
  },
  {
    "uuid": "54197715.119116988",
    "id": 119116988,
    "title": "C#-内存管理(Stack和Heap)【Area】",
    "description": "每个线程对应一个stack，线程创建的时候CLR为其创建这个stack，stack主要作用是记录函数的执行情况。值类型变量（函数的参数、局部变量 等非成员变量）都分配在stack中，引用类型的对象分配在heap中，在stack中保存heap对象的引用指针。GC只负责heap对象的释放，heap...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 1228,
    "created_at": "2023-03-22T11:38:10",
    "updated_at": "2024-10-22T10:57:58"
  },
  {
    "uuid": "54197715.119122075",
    "id": 119122075,
    "title": "C#-CLR、内存分配和内存回收【Area】",
    "description": "CLRCLR：即公共语言运行时(Common Language Runtime)，是中间语言（IL）的运行时环境，负责将编译生成的MSIL编译成计算机可以识别的机器码，负责资源管理（内存分配和垃圾回收等）。可能有人会提问：为什么不直接编译成机器码，而要先编译成IL，然后在编译成机器码呢？原因是...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 4503,
    "created_at": "2023-03-22T12:29:01",
    "updated_at": "2024-08-17T03:29:32"
  },
  {
    "uuid": "54197715.119475983",
    "id": 119475983,
    "title": "C#-异步编程【Area】",
    "description": "什么是异步同步和异步主要用于修饰方法。当一个方法被调用时，调用者需要等待该方法执行完毕并返回才能继续执行，我们称这个方法是同步方法；当一个方法被调用时立即返回，并获取一个线程执行该方法内部的业务，调用者不用等待该方法执行完毕，我们称这个方法为异步方法。Thread < ThreadPoll <...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 4977,
    "created_at": "2023-03-26T06:11:43",
    "updated_at": "2024-08-19T12:04:28"
  },
  {
    "uuid": "54197715.119594211",
    "id": 119594211,
    "title": "WPF-MVVM(使用MvvmLight插件)【Area】",
    "description": "MVVM介绍其实就是：Model 、view、viewmodel三个的简称，就像MVC一样。model就是模型。view就是视图。viewmodel就是和view进行绑定的。MVVM示意图如下所示：安装MvvmLight插件MVVM开发步骤主要通过MVVM实现数据的CRUD【增删改查】基础操作...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 1562,
    "created_at": "2023-03-27T07:43:01",
    "updated_at": "2024-08-17T03:31:43"
  },
  {
    "uuid": "54197715.119613878",
    "id": 119613878,
    "title": "WPF-命令(ICommand)【Area】",
    "description": "使用Command可以实现UI层跟业务层分离，不必在UI层定义事件方法，近而减少耦合。开发示例界面展示_UI层<Window x:Class=\"WpfCommand.MainWindow\"         xmlns=\"http://schemas.microsoft.com/winfx/20...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 211,
    "created_at": "2023-03-27T09:15:40",
    "updated_at": "2024-08-22T14:47:51"
  },
  {
    "uuid": "54197715.119618116",
    "id": 119618116,
    "title": "WPF-通知更改INotifyPropertyChanged【Area】",
    "description": "有两种方式简单方式-在赋值的时候调用PropertyChangednamespace WpfApp1 {     public class MainViewModel:INotifyPropertyChanged     {         public MyCommand ShowComma...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 204,
    "created_at": "2023-03-27T09:40:54",
    "updated_at": "2024-08-22T14:47:42"
  },
  {
    "uuid": "54197715.119618807",
    "id": 119618807,
    "title": "WPF-绑定【Area】",
    "description": "开发示例前端ui",
    "book_id": 54197715,
    "public": 0,
    "word_count": 249,
    "created_at": "2023-03-27T09:45:29",
    "updated_at": "2024-10-20T10:01:06"
  },
  {
    "uuid": "54197715.119619453",
    "id": 119619453,
    "title": "WPF-依赖属性【Area】",
    "description": "依赖属性介绍WPF提供了一组服务，这些服务可用于扩展公共语言运行时 (CLR) 属性的功能。 这些服务通常统称为 WPF 属性系统。 由 WPF 属性系统支持的属性称为依赖属性。为什么要使用依赖属性场景一：一个界面有100个按钮，每个按钮有100个属性，那么系统需要为10000个属性分配内存，...",
    "book_id": 54197715,
    "public": 0,
    "word_count": 1102,
    "created_at": "2023-03-27T09:50:09",
    "updated_at": "2024-10-20T09:59:20"
  }
]