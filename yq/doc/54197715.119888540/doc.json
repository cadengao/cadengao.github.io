{
  "uuid": "54197715.119888540",
  "id": 119888540,
  "title": "WPF-Invoke与BeginInvoke的区别【Area】",
  "cover": "",
  "book_id": 54197715,
  "book_name": "Area",
  "public": 0,
  "word_count": 565,
  "created_at": "2023-03-29T10:20:47",
  "updated_at": "2024-10-22T08:13:38",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><p id=\"ud6b5b346\" class=\"ne-p\"><span class=\"ne-text\">在WPF多线程编程中，经常要在工作线程中更新界面显示，Invoke和BeginInvoke即是为了解决此类问题。在WPF多线程编程模型中，通过Dispatcher调度程序，来管理UI工作项队列，并拥有应用程序主线程，在大多数WPF应用程序中，只存在一个用户界面线程和一个调度器。</span></p><p id=\"uc7fa3e77\" class=\"ne-p\"><span class=\"ne-text\">在非UI线程更新UI，通过调用Invoke和BeginInvoke来实现，那么两者有什么区别呢？</span></p><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u2c695fc6\" data-lake-index-type=\"2\"><span class=\"ne-text\">不同点：</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"ubd75305d\" data-lake-index-type=\"2\"><span class=\"ne-text\">Invoke是同步更新，会阻塞所在工作者线程，BeginInvoke是异步更新，不会阻塞当前线程。</span></li><li id=\"uf98ad8b9\" data-lake-index-type=\"2\"><span class=\"ne-text\">Invoke调用后将指定代码立即插入主线程中执行，而BeginInvoke调用后，发送消息给UI线程，相当于向Dispatcher队列中添加工作项，待之前UI更新任务完成后，再执行BeginInvoke中的内容。</span></li><li id=\"u50bf0806\" data-lake-index-type=\"2\"><span class=\"ne-text\">在使用场景上，Invoke方法会拖延线程直到执行完指定代码，如果需要暂停异步操作，直到用户提供反馈信息，可使用Invoke，比如指定代码弹出YES/NO对话框，需要根据用户反馈以进一步执行操作的场景。</span></li></ol></ol><ol start=\"2\" class=\"ne-ol\"><li id=\"ua02d612e\" data-lake-index-type=\"0\"><span class=\"ne-text\">相同点：两者虽然一个为同步，一个为异步，实际是运行在同一线程，即UI主线程。</span></li></ol><p id=\"ud6921f76\" class=\"ne-p\"><span class=\"ne-text\">代码示例：</span></p><pre data-language=\"csharp\" id=\"CFEyz\" class=\"ne-codeblock language-csharp\"><code>void ButtonClick(object sender, RoutedEventArgs e)\n{\n    //在UI线程(主线程)中调用Invoke和BeginInvoke(一般不这样用，没有实际意义)\n    //这里会阻塞UI\n    this.Dispatcher.Invoke(() =&gt;\n     {\n         this.ContentTextBlock.Text += &quot;Main thread Invoke and thread id :&quot; + Thread.CurrentThread.ManagedThreadId + '\\n';\n     });\n\t//这里不会阻塞UI\n     this.Dispatcher.BeginInvoke(new Action(delegate\n     {\n         this.ContentTextBlock.Text += &quot;Main thread BeginInvoke and thread id :&quot; + Thread.CurrentThread.ManagedThreadId + '\\n';\n     }));\n     //在工作者线程中调用Invoke和BeginInvoke\n    Task.Factory.StartNew(() =&gt;\n    {\n        //这里会阻塞UI\n        this.Dispatcher.Invoke(() =&gt;\n        {\n            this.ContentTextBlock.Text += &quot; Worker thread Invoke and thread id :&quot; + Thread.CurrentThread.ManagedThreadId + '\\n';\n        });\n\t\t//这里不会阻塞UI\n        this.Dispatcher.BeginInvoke(new Action(delegate\n        {\n            this.ContentTextBlock.Text += &quot; Worker thread BeginInvoke and thread id :&quot; + Thread.CurrentThread.ManagedThreadId + '\\n';\n        }));\n    });\n}\n\n//输出结果\nMain thread Invoke and thread id : 10\nMain thread BeginInvoke and thread id : 10\nWorker thread Invoke and thread id : 10\nWorker thread BeginInvoke and thread id : 10</code></pre></div>"
}