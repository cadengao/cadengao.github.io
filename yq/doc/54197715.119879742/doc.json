{
  "uuid": "54197715.119879742",
  "id": 119879742,
  "title": "C#-线程同步【Area】",
  "cover": "https://cdn.nlark.com/yuque/0/2023/png/123299/1680082378820-27e341b3-dc3f-4663-a0bd-543b24449b1e.png",
  "book_id": 54197715,
  "book_name": "Area",
  "public": 0,
  "word_count": 4626,
  "created_at": "2023-03-29T09:29:13",
  "updated_at": "2024-10-22T11:00:59",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h2 id=\"FWQT0\"><span class=\"ne-text\">简介</span></h2><p id=\"u4a350ed4\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">本章介绍在C#中实现线程同步的几种方法。因为多个线程同时访问共享数据时，可能会造成共享数据的损坏，从而导致与预期的结果不相符。为了解决这个问题，所以需要用到线程同步，也被俗称为“加锁”。但是</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">加锁绝对不对提高性能，最多也就是不增不减</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，要实现性能不增不减还得靠高质量的</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">同步源语</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">(Synchronization Primitive)。但是因为</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">正确永远比速度更重要</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，所以线程同步在某些场景下是必须的。</span></p><p id=\"u556ddc7f\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">线程同步有两种源语(Primitive)构造：</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">用户模式(user - mode)</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">和</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">内核模式(kernel - mode)</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，当资源可用时间短的情况下，用户模式要</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">优于</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">内核模式，但是如果长时间不能获得资源，或者说长时间处于“自旋”，那么内核模式是相对来说好的选择。</span></p><p id=\"u356cae7b\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">但是我们希望兼具用户模式和内核模式的优点，我们把它称为</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">混合构造(hybrid construct)</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，它兼具了两种模式的优点。</span></p><p id=\"u8a97b114\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">在C#中有多种线程同步的机制，通常可以按照以下顺序进行选择。</span></p><div class=\"ne-quote\"><ol class=\"ne-ol\"><li id=\"ue0fcb134\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">如果代码能通过优化可以不进行同步，那么就不要做同步。</span></li><li id=\"u14a86c87\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">使用原子性的</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Interlocked</span></code><span class=\"ne-text\" style=\"font-size: 16px\">方法。</span></li><li id=\"ud2796a9b\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">使用</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">lock/Monitor</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类。</span></li><li id=\"u35b82a49\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">使用异步锁，如</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">SemaphoreSlim.WaitAsync()</span></code><span class=\"ne-text\" style=\"font-size: 16px\">。</span></li><li id=\"ua9456a58\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">使用其它加锁机制，如</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ReaderWriterLockSlim、Mutex、Semaphore</span></code><span class=\"ne-text\" style=\"font-size: 16px\">等。</span></li><li id=\"uc8446999\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">如果系统提供了</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">*Slim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">版本的异步对象，那么请选用它，因为</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">*Slim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">版本全部都是混合锁，在进入内核模式前实现了某种形式的自旋。</span></li></ol></div><p id=\"u004a977a\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">在同步中，一定要注意避免死锁的发生，死锁的发生必须满足以下4个基本条件，所以只需要破坏任意一个条件，就可避免发生死锁。</span></p><div class=\"ne-quote\"><ol class=\"ne-ol\"><li id=\"u847d14f5\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">排他或互斥(Mutual exclusion)：一个线程(ThreadA)独占一个资源，没有其它线程(ThreadB)能获取相同的资源。</span></li><li id=\"u803c3e1b\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">占有并等待(Hold and wait)：互斥的一个线程(ThreadA)请求获取另一个线程(ThreadB)占有的资源.</span></li><li id=\"u4bbfe6a3\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">不可抢先(No preemption)：一个线程(ThreadA)占有资源不能被强制拿走(只能等待ThreadA主动释放它的资源)。</span></li><li id=\"ub3e0d6a6\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">循环等待条件(Circular wait condition)：两个或多个线程构成一个循环等待链，它们锁定两个或多个相同的资源，每个线程都在等待链中的下一个线程占有的资源。</span></li></ol></div><h2 id=\"w3Ct5\"><span class=\"ne-text\">执行基本原子操作</span></h2><p id=\"udd6bf517\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">CLR保证了对这些数据类型的读写是原子性的：</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Boolean、Char、(S)Byte、(U)Int16、(U)Int32、(U)IntPtr和Single</span></code><span class=\"ne-text\" style=\"font-size: 16px\">。但是如果读写</span><span class=\"ne-text\" style=\"font-size: 16px\">Int64</span><span class=\"ne-text\" style=\"font-size: 16px\">可能会发生读取撕裂(torn read)的问题，因为在32位操作系统中，它需要执行两次</span><span class=\"ne-text\" style=\"font-size: 16px\">Mov</span><span class=\"ne-text\" style=\"font-size: 16px\">操作，无法在一个时间内执行完成。</span></p><p id=\"u6ddd5f49\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">那么在本节中，就会着重的介绍</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">System.Threading.Interlocked</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类提供的方法，</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Interlocked</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类中的每个方法都是执行一次的读取以及写入操作。更多与</span><span class=\"ne-text\" style=\"font-size: 16px\">Interlocked</span><span class=\"ne-text\" style=\"font-size: 16px\">类相关的资料请参考链接，</span><a href=\"https://msdn.microsoft.com/zh-cn/library/system.threading.interlocked(v=vs.110).aspx\" data-href=\"https://msdn.microsoft.com/zh-cn/library/system.threading.interlocked(v=vs.110).aspx\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">戳一戳</span></a><span class=\"ne-text\" style=\"font-size: 16px\">本文不在赘述。</span></p><p id=\"u49d2b0a5\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">演示代码如下所示，分别使用了三种方式进行计数：错误计数方式、</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">lock</span></code><span class=\"ne-text\" style=\"font-size: 16px\">锁方式和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Interlocked</span></code><span class=\"ne-text\" style=\"font-size: 16px\">原子方式。</span></p><pre data-language=\"csharp\" id=\"AwY8I\" class=\"ne-codeblock language-csharp\"><code>private static void Main(string[] args)\n{\n    Console.WriteLine(&quot;错误的计数&quot;);\n\n    var c = new Counter();\n    Execute(c);\n\n    Console.WriteLine(&quot;--------------------------&quot;);\n\n\n    Console.WriteLine(&quot;正确的计数 - 有锁&quot;);\n\n    var c2 = new CounterWithLock();\n    Execute(c2);\n\n    Console.WriteLine(&quot;--------------------------&quot;);\n\n\n    Console.WriteLine(&quot;正确的计数 - 无锁&quot;);\n\n    var c3 = new CounterNoLock();\n    Execute(c3);\n\n    Console.ReadLine();\n}\n\nstatic void Execute(CounterBase c)\n{\n    // 统计耗时\n    var sw = new Stopwatch();\n    sw.Start();\n\n    var t1 = new Thread(() =&gt; TestCounter(c));\n    var t2 = new Thread(() =&gt; TestCounter(c));\n    var t3 = new Thread(() =&gt; TestCounter(c));\n    t1.Start();\n    t2.Start();\n    t3.Start();\n    t1.Join();\n    t2.Join();\n    t3.Join();\n\n    sw.Stop();\n    Console.WriteLine($&quot;Total count: {c.Count} Time:{sw.ElapsedMilliseconds} ms&quot;);\n}\n\nstatic void TestCounter(CounterBase c)\n{\n    for (int i = 0; i &lt; 100000; i++)\n    {\n        c.Increment();\n        c.Decrement();\n    }\n}\n\nclass Counter : CounterBase\n{\n    public override void Increment()\n    {\n        _count++;\n    }\n\n    public override void Decrement()\n    {\n        _count--;\n    }\n}\n\nclass CounterNoLock : CounterBase\n{\n    public override void Increment()\n    {\n        // 使用Interlocked执行原子操作\n        Interlocked.Increment(ref _count);\n    }\n\n    public override void Decrement()\n    {\n        Interlocked.Decrement(ref _count);\n    }\n}\n\nclass CounterWithLock : CounterBase\n{\n    private readonly object _syncRoot = new Object();\n\n    public override void Increment()\n    {\n        // 使用Lock关键字 锁定私有变量\n        lock (_syncRoot)\n        {\n            // 同步块\n            Count++;\n        }\n    }\n\n    public override void Decrement()\n    {\n        lock (_syncRoot)\n        {\n            Count--;\n        }\n    }\n}\n\n\nabstract class CounterBase\n{\n    protected int _count;\n\n    public int Count\n    {\n        get\n        {\n            return _count;\n        }\n        set\n        {\n            _count = value;\n        }\n    }\n\n    public abstract void Increment();\n\n    public abstract void Decrement();\n}\n</code></pre><p id=\"u17642f78\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下所示，与预期结果基本相符。</span></p><p id=\"u06ab2426\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/0.png\" width=\"739\" id=\"uaa0a1d79\" class=\"ne-image\"></p><h2 id=\"zNc77\"><span class=\"ne-text\">使用Mutex类</span></h2><p id=\"ued9d9974\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">System.Threading.Mutex</span></code><span class=\"ne-text\" style=\"font-size: 16px\">在概念上和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">System.Threading.Monitor</span></code><span class=\"ne-text\" style=\"font-size: 16px\">几乎一样，但是</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Mutex</span></code><span class=\"ne-text\" style=\"font-size: 16px\">同步对文件或者其他跨进程的资源进行访问，也就是说</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Mutex</span></code><span class=\"ne-text\" style=\"font-size: 16px\">是可跨进程的。因为其特性，它的一个用途是限制应用程序不能同时运行多个实例。</span></p><p id=\"u6d9c4fbf\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Mutex</span></code><span class=\"ne-text\" style=\"font-size: 16px\">对象支持递归，也就是说同一个线程</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">可多次获取同一个锁</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，这在后面演示代码中可观察到。由于</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Mutex</span></code><span class=\"ne-text\" style=\"font-size: 16px\">的基类</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">System.Theading.WaitHandle</span></code><span class=\"ne-text\" style=\"font-size: 16px\">实现了</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">IDisposable</span></code><span class=\"ne-text\" style=\"font-size: 16px\">接口，所以当不需要在使用它时要注意进行资源的释放。更多资料：</span><a href=\"https://msdn.microsoft.com/zh-cn/library/system.threading.mutex.aspx\" data-href=\"https://msdn.microsoft.com/zh-cn/library/system.threading.mutex.aspx\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">戳一戳</span></a></p><p id=\"ue5c4a7b4\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">演示代码如下所示，简单的演示了如何创建单实例的应用程序和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Mutex</span></code><span class=\"ne-text\" style=\"font-size: 16px\">递归获取锁的实现。</span></p><pre data-language=\"csharp\" id=\"I5Wfz\" class=\"ne-codeblock language-csharp\"><code>const string MutexName = &quot;CSharpThreadingCookbook&quot;;\n\nstatic void Main(string[] args)\n{\n    // 使用using 及时释放资源\n    using (var m = new Mutex(false, MutexName))\n    {\n        if (!m.WaitOne(TimeSpan.FromSeconds(5), false))\n        {\n            Console.WriteLine(&quot;已经有实例正在运行!&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;运行中...&quot;);\n\n            // 演示递归获取锁\n            Recursion();\n\n            Console.ReadLine();\n            m.ReleaseMutex();\n        }\n    }\n\n    Console.ReadLine();\n}\n\nstatic void Recursion()\n{\n    using (var m = new Mutex(false, MutexName))\n    {\n        if (!m.WaitOne(TimeSpan.FromSeconds(2), false))\n        {\n            // 因为Mutex支持递归获取锁 所以永远不会执行到这里\n            Console.WriteLine(&quot;递归获取锁失败！&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;递归获取锁成功！&quot;);\n        }\n    }\n}\n</code></pre><p id=\"uf0888f94\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下图所示，打开了两个应用程序，因为使用</span><code class=\"ne-code\"><span class=\"ne-text\">Mutex</span></code><span class=\"ne-text\" style=\"font-size: 16px\">实现了单实例，所以第二个应用程序无法获取锁，就会显示</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">已有实例正在运行</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">。</span></p><p id=\"u894f7fca\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/1.png\" width=\"1026\" id=\"uf8f6f119\" class=\"ne-image\"></p><h2 id=\"Krj9y\"><span class=\"ne-text\">使用SemaphoreSlim类</span></h2><p id=\"u6b9d7ab0\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">SemaphoreSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类与之前提到的同步类有锁不同，之前提到的同步类都是互斥的，也就是说只允许一个线程进行访问资源，而</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">SemaphoreSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">是可以允许多个访问。</span></p><p id=\"u0b50d8f7\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">在之前的部分有提到，以</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">*Slim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">结尾的线程同步类，都是工作在混合模式下的，也就是说开始它们都是在用户模式下&quot;自旋&quot;，等发生第一次竞争时，才切换到内核模式。但是</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">SemaphoreSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">不同于</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Semaphore</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类，它不支持系统信号量，所以它</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">不能用于进程之间的同步</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">。</span></p><p id=\"u296a442f\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">该类使用比较简单，演示代码演示了6个线程竞争访问只允许4个线程同时访问的数据库，如下所示。</span></p><pre data-language=\"csharp\" id=\"NuOX9\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    // 创建6个线程 竞争访问AccessDatabase\n    for (int i = 1; i &lt;= 6; i++)\n    {\n        string threadName = &quot;线程 &quot; + i;\n        // 越后面的线程，访问时间越久 方便查看效果\n        int secondsToWait = 2 + 2 * i;\n        var t = new Thread(() =&gt; AccessDatabase(threadName, secondsToWait));\n        t.Start();\n    }\n\n    Console.ReadLine();\n}\n\n// 同时允许4个线程访问\nstatic SemaphoreSlim _semaphore = new SemaphoreSlim(4);\n\nstatic void AccessDatabase(string name, int seconds)\n{\n    Console.WriteLine($&quot;{name} 等待访问数据库.... {DateTime.Now.ToString(&quot;HH:mm:ss.ffff&quot;)}&quot;);\n\n    // 等待获取锁 进入临界区\n    _semaphore.Wait();\n\n    Console.WriteLine($&quot;{name} 已获取对数据库的访问权限 {DateTime.Now.ToString(&quot;HH:mm:ss.ffff&quot;)}&quot;);\n    // Do something\n    Thread.Sleep(TimeSpan.FromSeconds(seconds));\n\n    Console.WriteLine($&quot;{name} 访问完成... {DateTime.Now.ToString(&quot;HH:mm:ss.ffff&quot;)}&quot;);\n    // 释放锁\n    _semaphore.Release();\n}\n</code></pre><p id=\"udd7211cb\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下所示，可见前4个线程马上就获取到了锁，进入了临界区，而另外两个线程在等待；等有锁被释放时，才能进入临界区。</span></p><p id=\"u4175aedc\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/2.png\" width=\"739\" id=\"u902742f4\" class=\"ne-image\"></p><h2 id=\"HHIQF\"><span class=\"ne-text\">使用AutoResetEvent类</span></h2><p id=\"u2213fbab\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">AutoResetEvent</span></code><span class=\"ne-text\" style=\"font-size: 16px\">叫自动重置事件，虽然名称中有</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">事件</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">一词，但是重置事件和C#中的委托没有任何关系，这里的事件只是由内核维护的</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Boolean</span></code><span class=\"ne-text\" style=\"font-size: 16px\">变量，当事件为</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">false</span></code><span class=\"ne-text\" style=\"font-size: 16px\">，那么在事件上等待的线程就阻塞；事件变为</span><span class=\"ne-text\" style=\"font-size: 16px\">true</span><span class=\"ne-text\" style=\"font-size: 16px\">，那么阻塞解除。</span></p><p id=\"uee2c61ba\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">在.Net中有两种此类事件，即</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">AutoResetEvent</span></code><span class=\"ne-text\" style=\"font-size: 16px\">(自动重置事件)</span><span class=\"ne-text\" style=\"font-size: 16px\">和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ManualResetEvent</span></code><span class=\"ne-text\" style=\"font-size: 16px\">(手动重置事件)</span><span class=\"ne-text\" style=\"font-size: 16px\">。这两者均是采用</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">内核模式</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">，它的区别在于当重置事件为</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">true</span></code><span class=\"ne-text\" style=\"font-size: 16px\">时，</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">自动重置事件它只唤醒一个阻塞的线程，会自动将事件重置回</span></strong><code class=\"ne-code\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">false</span></strong></code><span class=\"ne-text\" style=\"font-size: 16px\">，造成其它线程继续阻塞。而</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">手动重置事件不会自动重置，必须通过代码手动重置回</span></strong><code class=\"ne-code\"><strong><span class=\"ne-text\" style=\"font-size: 16px\">false</span></strong></code><span class=\"ne-text\" style=\"font-size: 16px\">。</span></p><p id=\"u7558c2ba\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">因为以上的原因，所以在很多文章和书籍中不推荐使用</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">AutoResetEvent</span></code><span class=\"ne-text\" style=\"font-size: 16px\">(自动重置事件)</span><span class=\"ne-text\" style=\"font-size: 16px\">，因为它很容易在编写生产者线程时发生失误，造成它的迭代次数多余消费者线程。</span></p><p id=\"u1b314210\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">演示代码如下所示，该代码演示了通过</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">AutoResetEvent</span></code><span class=\"ne-text\" style=\"font-size: 16px\">实现两个线程的互相同步。</span></p><pre data-language=\"csharp\" id=\"SbiZd\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    var t = new Thread(() =&gt; Process(10));\n    t.Start();\n\n    Console.WriteLine(&quot;等待另一个线程完成工作！&quot;);\n    // 等待工作线程通知 主线程阻塞\n    _workerEvent.WaitOne();\n    Console.WriteLine(&quot;第一个操作已经完成！&quot;);\n    Console.WriteLine(&quot;在主线程上执行操作&quot;);\n    Thread.Sleep(TimeSpan.FromSeconds(5));\n\n    // 发送通知 工作线程继续运行\n    _mainEvent.Set();\n    Console.WriteLine(&quot;现在在第二个线程上运行第二个操作&quot;);\n\n    // 等待工作线程通知 主线程阻塞\n    _workerEvent.WaitOne();\n    Console.WriteLine(&quot;第二次操作完成！&quot;);\n\n    Console.ReadLine();\n}\n\n// 工作线程Event\nprivate static AutoResetEvent _workerEvent = new AutoResetEvent(false);\n// 主线程Event\nprivate static AutoResetEvent _mainEvent = new AutoResetEvent(false);\n\nstatic void Process(int seconds)\n{\n    Console.WriteLine(&quot;开始长时间的工作...&quot;);\n    Thread.Sleep(TimeSpan.FromSeconds(seconds));\n    Console.WriteLine(&quot;工作完成!&quot;);\n\n    // 发送通知 主线程继续运行\n    _workerEvent.Set();\n    Console.WriteLine(&quot;等待主线程完成其它工作&quot;);\n\n    // 等待主线程通知 工作线程阻塞\n    _mainEvent.WaitOne();\n    Console.WriteLine(&quot;启动第二次操作...&quot;);\n    Thread.Sleep(TimeSpan.FromSeconds(seconds));\n    Console.WriteLine(&quot;工作完成!&quot;);\n\n    // 发送通知 主线程继续运行\n    _workerEvent.Set();\n}\n</code></pre><p id=\"u73a3cb3d\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下图所示，与预期结果符合。</span></p><p id=\"uab4b74dd\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/3.png\" width=\"760\" id=\"u86dafb0c\" class=\"ne-image\"></p><h2 id=\"Lplwl\"><span class=\"ne-text\">使用ManualResetEventSlim类</span></h2><p id=\"uec1936a0\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ManualResetEventSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">使用和</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ManualResetEvent</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类基本一致，只是</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ManualResetEventSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">工作在</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">混合模式</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">下，而它与</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">AutoResetEventSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">不同的地方就是需要手动重置事件，也就是调用</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Reset()</span></code><span class=\"ne-text\" style=\"font-size: 16px\">才能将事件重置为</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">false</span></code><span class=\"ne-text\" style=\"font-size: 16px\">。</span></p><p id=\"u3ff937a6\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">演示代码如下，形象的将</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ManualResetEventSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">比喻成大门，当事件为</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">true</span></code><span class=\"ne-text\" style=\"font-size: 16px\">时大门打开，线程解除阻塞；而事件为</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">false</span></code><span class=\"ne-text\" style=\"font-size: 16px\">时大门关闭，线程阻塞。</span></p><pre data-language=\"csharp\" id=\"V5jcf\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    var t1 = new Thread(() =&gt; TravelThroughGates(&quot;Thread 1&quot;, 5));\n    var t2 = new Thread(() =&gt; TravelThroughGates(&quot;Thread 2&quot;, 6));\n    var t3 = new Thread(() =&gt; TravelThroughGates(&quot;Thread 3&quot;, 12));\n    t1.Start();\n    t2.Start();\n    t3.Start();\n    // 休眠6秒钟  只有Thread 1小于 6秒钟，所以事件重置时 Thread 1 肯定能进入大门  而 Thread 2 可能可以进入大门\n    Thread.Sleep(TimeSpan.FromSeconds(6));\n    Console.WriteLine($&quot;大门现在打开了!  时间：{DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n    _mainEvent.Set();\n    // 休眠2秒钟 此时 Thread 2 肯定可以进入大门\n    Thread.Sleep(TimeSpan.FromSeconds(2));\n    _mainEvent.Reset();\n    Console.WriteLine($&quot;大门现在关闭了! 时间：{DateTime.Now.ToString(&quot;mm: ss.ffff&quot;)}&quot;);\n    // 休眠10秒钟 Thread 3 可以进入大门\n    Thread.Sleep(TimeSpan.FromSeconds(10));\n    Console.WriteLine($&quot;大门现在第二次打开! 时间：{DateTime.Now.ToString(&quot;mm: ss.ffff&quot;)}&quot;);\n    _mainEvent.Set();\n    Thread.Sleep(TimeSpan.FromSeconds(2));\n    Console.WriteLine($&quot;大门现在关闭了! 时间：{DateTime.Now.ToString(&quot;mm: ss.ffff&quot;)}&quot;);\n    _mainEvent.Reset();\n    Console.ReadLine();\n}\nstatic void TravelThroughGates(string threadName, int seconds)\n{\n    Console.WriteLine($&quot;{threadName} 进入睡眠 时间：{DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n    Thread.Sleep(TimeSpan.FromSeconds(seconds));\n    Console.WriteLine($&quot;{threadName} 等待大门打开! 时间：{DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n    _mainEvent.Wait();\n    Console.WriteLine($&quot;{threadName} 进入大门! 时间：{DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n}\nstatic ManualResetEventSlim _mainEvent = new ManualResetEventSlim(false);</code></pre><p id=\"u66c9bf5c\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下，与预期结果相符。</span></p><p id=\"u9aa2cff5\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/4.png\" width=\"771\" id=\"u62fcc003\" class=\"ne-image\"></p><h2 id=\"fZr81\"><span class=\"ne-text\">使用CountDownEvent类</span></h2><p id=\"uc33a5de2\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">CountDownEvent</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类内部构造使用了一个</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ManualResetEventSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">对象。这个构造阻塞一个线程，直到它内部计数器</span><span class=\"ne-text\" style=\"font-size: 16px\">(</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">CurrentCount</span></code><span class=\"ne-text\" style=\"font-size: 16px\">)</span><span class=\"ne-text\" style=\"font-size: 16px\">变为</span><span class=\"ne-text\" style=\"font-size: 16px\">0</span><span class=\"ne-text\" style=\"font-size: 16px\">时，才解除阻塞。也就是说它并不是阻止对已经枯竭的资源池的访问，而是只有当计数为</span><span class=\"ne-text\" style=\"font-size: 16px\">0</span><span class=\"ne-text\" style=\"font-size: 16px\">时才允许访问。</span></p><p id=\"uda9294af\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">这里需要注意的是，当</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">CurrentCount</span></code><span class=\"ne-text\" style=\"font-size: 16px\">变为</span><span class=\"ne-text\" style=\"font-size: 16px\">0</span><span class=\"ne-text\" style=\"font-size: 16px\">时，那么它就不能被更改了。为</span><span class=\"ne-text\" style=\"font-size: 16px\">0</span><span class=\"ne-text\" style=\"font-size: 16px\">以后，</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Wait()</span></code><span class=\"ne-text\" style=\"font-size: 16px\">方法的阻塞被解除。</span></p><p id=\"uc204ab15\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">演示代码如下所示，只有当</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Signal()</span></code><span class=\"ne-text\" style=\"font-size: 16px\">方法被调用2次以后，</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Wait()</span></code><span class=\"ne-text\" style=\"font-size: 16px\">方法的阻塞才被解除。</span></p><pre data-language=\"csharp\" id=\"VjvgH\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    Console.WriteLine($&quot;开始两个操作  {DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n    var t1 = new Thread(() =&gt; PerformOperation(&quot;操作 1 完成！&quot;, 4));\n    var t2 = new Thread(() =&gt; PerformOperation(&quot;操作 2 完成！&quot;, 8));\n    t1.Start();\n    t2.Start();\n\n    // 等待操作完成\n    _countdown.Wait();\n    Console.WriteLine($&quot;所有操作都完成  {DateTime.Now.ToString(&quot;mm: ss.ffff&quot;)}&quot;);\n    _countdown.Dispose();\n\n    Console.ReadLine();\n}\n\n// 构造函数的参数为2 表示只有调用了两次 Signal方法 CurrentCount 为 0时  Wait的阻塞才解除\nstatic CountdownEvent _countdown = new CountdownEvent(2);\n\nstatic void PerformOperation(string message, int seconds)\n{\n    Thread.Sleep(TimeSpan.FromSeconds(seconds));\n    Console.WriteLine($&quot;{message}  {DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n\n    // CurrentCount 递减 1\n    _countdown.Signal();\n}</code></pre><p id=\"u31aa2fda\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下图所示，可见只有当操作1和操作2都完成以后，才执行输出所有操作都完成。</span></p><p id=\"u44b68a2c\" class=\"ne-p\"><a href=\"https://images2018.cnblogs.com/blog/997046/201808/997046-20180803213629728-1953466335.png\" target=\"_blank\" id=\"uae386719\" class=\"ne-image-link\" style=\"font-size: 16px\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/5.png\" width=\"802\" class=\"ne-image\"></a></p><h2 id=\"NzeJ9\"><span class=\"ne-text\">使用Barrier类</span></h2><p id=\"u73cada91\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Barrier</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类用于解决一个非常稀有的问题，平时一般用不上。</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">Barrier</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类控制一系列线程进行阶段性的并行工作。</span></p><p id=\"u362c9210\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">假设现在并行工作分为2个阶段，每个线程在完成它自己那部分阶段1的工作后，必须停下来等待其它线程完成阶段1的工作；等所有线程均完成阶段1工作后，每个线程又开始运行，完成阶段2工作，等待其它线程全部完成阶段2工作后，整个流程才结束。</span></p><p id=\"u5d139383\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">演示代码如下所示，该代码演示了两个线程分阶段的完成工作。</span></p><pre data-language=\"csharp\" id=\"IbZ0K\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    var t1 = new Thread(() =&gt; PlayMusic(&quot;钢琴家&quot;, &quot;演奏一首令人惊叹的独奏曲&quot;, 5));\n    var t2 = new Thread(() =&gt; PlayMusic(&quot;歌手&quot;, &quot;唱着他的歌&quot;, 2));\n\n    t1.Start();\n    t2.Start();\n\n    Console.ReadLine();\n}\n\nstatic Barrier _barrier = new Barrier(2, Console.WriteLine($&quot;第 {b.CurrentPhaseNumber + 1} 阶段结束&quot;));\n\nstatic void PlayMusic(string name, string message, int seconds)\n{\n    for (int i = 1; i &lt; 3; i++)\n    {\n        Console.WriteLine(&quot;----------------------------------------------&quot;);\n        Thread.Sleep(TimeSpan.FromSeconds(seconds));\n        Console.WriteLine($&quot;{name} 开始 {message}&quot;);\n        Thread.Sleep(TimeSpan.FromSeconds(seconds));\n        Console.WriteLine($&quot;{name} 结束 {message}&quot;);\n        _barrier.SignalAndWait();\n    }\n}</code></pre><p id=\"ue7253835\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下所示，当“歌手”线程完成后，并没有马上结束，而是等待“钢琴家”线程结束，当&quot;钢琴家&quot;线程结束后，才开始第2阶段的工作。</span></p><p id=\"u770fd154\" class=\"ne-p\"><a href=\"https://images2018.cnblogs.com/blog/997046/201808/997046-20180803213629433-1754678694.png\" target=\"_blank\" id=\"uecea8fc8\" class=\"ne-image-link\" style=\"font-size: 16px\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/6.png\" width=\"727\" class=\"ne-image\"></a></p><h2 id=\"mHpin\"><span class=\"ne-text\">使用ReaderWriterLockSlim类</span></h2><p id=\"u79ebfc45\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ReaderWriterLockSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类主要是解决在某些场景下，</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">读操作多于写操作</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">而使用某些互斥锁当多个线程同时访问资源时，只有一个线程能访问，导致性能急剧下降。</span></p><p id=\"u3153a865\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">如果所有线程都希望以只读的方式访问数据，就根本没有必要阻塞它们；如果一个线程希望修改数据，那么这个线程才需要独占访问，这就是</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ReaderWriterLockSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">的典型应用场景。这个类就像下面这样来控制线程。</span></p><div class=\"ne-quote\"><ul class=\"ne-ul\"><li id=\"u1d19f797\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">一个线程向数据写入是，请求访问的其他所有线程都被阻塞。</span></li><li id=\"ubb12f96c\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">一个线程读取数据时，请求读取的线程允许读取，而请求写入的线程被阻塞。</span></li><li id=\"u7e0c8468\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">写入线程结束后，要么解除一个写入线程的阻塞，使写入线程能向数据接入，要么解除</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">所有</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">读取线程的阻塞，使它们能并发读取数据。如果线程没有被阻塞，锁就可以进入自由使用的状态，可供下一个读线程或写线程获取。</span></li><li id=\"uf3129a24\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"font-size: 16px\">从数据读取的所有线程结束后，一个写线程被解除阻塞，使它能向数据写入。如果线程没有被阻塞，锁就可以进入自由使用的状态，可供下一个读线程或写线程获取。</span></li></ul></div><p id=\"ub8e0d17f\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ReaderWriterLockSlim</span></code><span class=\"ne-text\" style=\"font-size: 16px\">还支持从</span><strong><span class=\"ne-text\" style=\"font-size: 16px\">读线程升级为写线程</span></strong><span class=\"ne-text\" style=\"font-size: 16px\">的操作，详情请</span><a href=\"https://msdn.microsoft.com/zh-cn/library/system.threading.readerwriterlockslim(v=vs.110).aspx\" data-href=\"https://msdn.microsoft.com/zh-cn/library/system.threading.readerwriterlockslim(v=vs.110).aspx\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">戳一戳</span></a><span class=\"ne-text\" style=\"font-size: 16px\">。文本不作介绍。</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">ReaderWriterLock</span></code><span class=\"ne-text\" style=\"font-size: 16px\">类已经过时，而且存在许多问题，没有必要去使用。</span></p><p id=\"uddc152b9\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">示例代码如下所示，创建了3个读线程，2个写线程，读线程和写线程竞争获取锁。</span></p><pre data-language=\"csharp\" id=\"K9JSx\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    // 创建3个 读线程\n    new Thread(() =&gt; Read(&quot;Reader 1&quot;)) { IsBackground = true }.Start();\n    new Thread(() =&gt; Read(&quot;Reader 2&quot;)) { IsBackground = true }.Start();\n    new Thread(() =&gt; Read(&quot;Reader 3&quot;)) { IsBackground = true }.Start();\n\n    // 创建两个写线程\n    new Thread(() =&gt; Write(&quot;Writer 1&quot;)) { IsBackground = true }.Start();\n    new Thread(() =&gt; Write(&quot;Writer 2&quot;)) { IsBackground = true }.Start();\n\n    // 使程序运行30S\n    Thread.Sleep(TimeSpan.FromSeconds(30));\n\n    Console.ReadLine();\n}\n\nstatic ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();\nstatic Dictionary&lt;int, int&gt; _items = new Dictionary&lt;int, int&gt;();\n\nstatic void Read(string threadName)\n{\n    while (true)\n    {\n        try\n        {\n            // 获取读锁定\n            _rw.EnterReadLock();\n            Console.WriteLine($&quot;{threadName} 从字典中读取内容  {DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n            foreach (var key in _items.Keys)\n            {\n                Thread.Sleep(TimeSpan.FromSeconds(0.1));\n            }\n        }\n        finally\n        {\n            // 释放读锁定\n            _rw.ExitReadLock();\n        }\n    }\n}\n\nstatic void Write(string threadName)\n{\n    while (true)\n    {\n        try\n        {\n            int newKey = new Random().Next(250);\n            // 尝试进入可升级锁模式状态\n            _rw.EnterUpgradeableReadLock();\n            if (!_items.ContainsKey(newKey))\n            {\n                try\n                {\n                    // 获取写锁定\n                    _rw.EnterWriteLock();\n                    _items[newKey] = 1;\n                    Console.WriteLine($&quot;{threadName} 将新的键 {newKey} 添加进入字典中  {DateTime.Now.ToString(&quot;mm:ss.ffff&quot;)}&quot;);\n                }\n                finally\n                {\n                    // 释放写锁定\n                    _rw.ExitWriteLock();\n                }\n            }\n            Thread.Sleep(TimeSpan.FromSeconds(0.1));\n        }\n        finally\n        {\n            // 减少可升级模式递归计数，并在计数为0时  推出可升级模式\n            _rw.ExitUpgradeableReadLock();\n        }\n    }\n}</code></pre><p id=\"u67744c2b\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下所示，与预期结果相符。</span></p><p id=\"u4ab98454\" class=\"ne-p\"><a href=\"https://images2018.cnblogs.com/blog/997046/201808/997046-20180803213629158-1425585239.png\" target=\"_blank\" id=\"u126c7020\" class=\"ne-image-link\" style=\"font-size: 16px\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/7.png\" width=\"981\" class=\"ne-image\"></a></p><h2 id=\"Yrzt2\"><span class=\"ne-text\">使用SpinWait类</span></h2><p id=\"u5c61b6ec\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">SpinWait</span></code><span class=\"ne-text\" style=\"font-size: 16px\">是一个常用的混合模式的类，它被设计成使用用户模式等待一段时间，人后切换至内核模式以节省CPU时间。</span></p><p id=\"u6a131a1c\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">它的使用非常简单，演示代码如下所示。</span></p><pre data-language=\"csharp\" id=\"uigIt\" class=\"ne-codeblock language-csharp\"><code>static void Main(string[] args)\n{\n    var t1 = new Thread(UserModeWait);\n    var t2 = new Thread(HybridSpinWait);\n\n    Console.WriteLine(&quot;运行在用户模式下&quot;);\n    t1.Start();\n    Thread.Sleep(20);\n    _isCompleted = true;\n    Thread.Sleep(TimeSpan.FromSeconds(1));\n    _isCompleted = false;\n\n    Console.WriteLine(&quot;运行在混合模式下&quot;);\n    t2.Start();\n    Thread.Sleep(5);\n    _isCompleted = true;\n\n    Console.ReadLine();\n}\n\nstatic volatile bool _isCompleted = false;\n\nstatic void UserModeWait()\n{\n    while (!_isCompleted)\n    {\n        Console.Write(&quot;.&quot;);\n    }\n    Console.WriteLine();\n    Console.WriteLine(&quot;等待结束&quot;);\n}\n\nstatic void HybridSpinWait()\n{\n    var w = new SpinWait();\n    while (!_isCompleted)\n    {\n        w.SpinOnce();\n        Console.WriteLine(w.NextSpinWillYield);\n    }\n    Console.WriteLine(&quot;等待结束&quot;);\n}</code></pre><p id=\"ue71d1986\" class=\"ne-p\"><span class=\"ne-text\" style=\"font-size: 16px\">运行结果如下两图所示，首先程序运行在模拟的用户模式下，使CPU有一个短暂的峰值。然后使用</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"font-size: 16px\">SpinWait</span></code><span class=\"ne-text\" style=\"font-size: 16px\">工作在混合模式下，首先标志变量为</span><span class=\"ne-text\" style=\"font-size: 16px\">False</span><span class=\"ne-text\" style=\"font-size: 16px\">处于用户模式自旋中，等待以后进入内核模式。</span></p><p id=\"uf6085883\" class=\"ne-p\"><a href=\"https://images2018.cnblogs.com/blog/997046/201808/997046-20180803213628846-1210659215.png\" target=\"_blank\" id=\"uc77a69a5\" class=\"ne-image-link\" style=\"font-size: 16px\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/8.png\" width=\"979\" class=\"ne-image\"></a></p><p id=\"u2744fd98\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119879742/image/9.png\" width=\"799\" id=\"ueab1ea21\" class=\"ne-image\"></p></div>"
}