{
  "uuid": "54197715.182315379",
  "id": 182315379,
  "title": "C#-值类型vs引用类型【Area】",
  "cover": "",
  "book_id": 54197715,
  "book_name": "Area",
  "public": 0,
  "word_count": 4461,
  "created_at": "2024-08-15T02:30:53",
  "updated_at": "2024-10-22T10:59:40",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h1 id=\"v4RNt\"><span class=\"ne-text\">问题：“谈谈值类型和引用的区别”。</span></h1><p id=\"u0b83f779\" class=\"ne-p\"><span class=\"ne-text\">对于这个问题，绝大部分人都只会给我两个简洁的答案：“值类型分配在栈中，引用类型分配在堆中”，“在默认情况下，值类型参数传值（拷贝），引用类型参数传引用”。</span></p><p id=\"ubb088945\" class=\"ne-p\"><span class=\"ne-text\">其实这个问题有很大的发挥空间，如果能够从内存布局、</span><code class=\"ne-code\"><span class=\"ne-text\">GC</span></code><span class=\"ne-text\">、互操作、跨</span><code class=\"ne-code\"><span class=\"ne-text\">AppDomain</span></code><span class=\"ne-text\">传递等方面展开，相信会加分不少。</span></p><p id=\"u96a74ea6\" class=\"ne-p\"><span class=\"ne-text\">下面</span><a href=\"https://www.cnblogs.com/artech/p/17509624.html\" data-href=\"https://www.cnblogs.com/artech/p/17509624.html\" target=\"_blank\" class=\"ne-link\"><span class=\"ne-text\">这篇文章</span></a><span class=\"ne-text\">独辟蹊径，从“变量”的角度讨论值类型和引用类型的区别。</span></p><h1 id=\"gJiNZ\"><span class=\"ne-text\">一、变量的地址</span></h1><p id=\"uef595df1\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">CLR</span></code><span class=\"ne-text\">是一个纯粹基于“栈”的虚拟机，所以在IL层面总是采用“压栈”的方式来传递参数，所以不论是引用类型还是值类型的变量，其</span><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">变量自身都是分配在栈上</span><span class=\"ne-text\">。而x86机器指令则是基于“栈+寄存器”，所以有些变量可能会最终存储在某个寄存器上，不过这不是这篇文章关注的问题。既然变量分配在栈上，那么它必然映射一个内存地址，指向该地址的指针可以采用如下这个</span><code class=\"ne-code\"><span class=\"ne-text\">AsPointer</span></code><span class=\"ne-text\">方法实现的方式提取出来。</span></p><p id=\"u8eebffa9\" class=\"ne-p\"><span class=\"ne-text\">不论是值类型还是引用类型，变量都是分配在栈（或者寄存器）上，所以每个变量具有一个内存地址，如下这个</span><code class=\"ne-code\"><span class=\"ne-text\">AsPointer</span></code><span class=\"ne-text\">方法通过调用</span><code class=\"ne-code\"><span class=\"ne-text\">Unsafe.AsPointer</span></code><span class=\"ne-text\">方法得到指定变量的指针</span><code class=\"ne-code\"><span class=\"ne-text\">（void*）</span></code><span class=\"ne-text\">，然后将其转换成</span><code class=\"ne-code\"><span class=\"ne-text\">IntPtr(nint)</span></code><span class=\"ne-text\">类型。</span></p><pre data-language=\"csharp\" id=\"TpDaV\" class=\"ne-codeblock language-csharp\"><code>internal static class Utility\n{\n    public static unsafe nint AsPointer&lt;T&gt;(ref T value) =&gt; new(Unsafe.AsPointer(ref value));\n}</code></pre><p id=\"u9d0ea9ef\" class=\"ne-p\"><span class=\"ne-text\">在如下的演示程序中，我定义具有相同数据成员的两个类型，其中</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarStruct</span></code><span class=\"ne-text\">为结构体，而</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarClass</span></code><span class=\"ne-text\">为类。我们先后定义了四个变量s1、c1、s2和c2，其中s2和c2的值是由s1和c1赋予的。我们调用上面这个</span><code class=\"ne-code\"><span class=\"ne-text\">AsPointer</span></code><span class=\"ne-text\">方法将四个变量的内存地址打印出来。</span></p><pre data-language=\"csharp\" id=\"K4R9X\" class=\"ne-codeblock language-csharp\"><code>var s1 = new FoobarStruct(255, 1);\nvar c1 = new FoobarClass(255, 1);\nvar s2 = s1;\nvar c2 = c1;\n\nConsole.WriteLine($&quot;s1: {Utility.AsPointer(ref s1)}&quot;);\nConsole.WriteLine($&quot;c1: {Utility.AsPointer(ref c1)}&quot;);\nConsole.WriteLine($&quot;s2: {Utility.AsPointer(ref s2)}&quot;);\nConsole.WriteLine($&quot;c2: {Utility.AsPointer(ref c2)}&quot;);\n\npublic class FoobarClass\n{\n    public byte Foo { get; set; }\n    public long Bar { get; set; }\n    public FoobarClass(byte foo, long bar)\n    {\n        Foo = foo;\n        Bar = bar;\n    }\n}\n\npublic struct FoobarStruct\n{\n    public byte Foo { get; set; }\n    public long Bar { get; set; }\n    public FoobarStruct(byte foo, long bar)\n    {\n        Foo = foo;\n        Bar = bar;\n    }\n}</code></pre><p id=\"u1360a52c\" class=\"ne-p\"><span class=\"ne-text\">如下所示的是程序运行后控制台上的输出结果。可以看出虽然s1和s2、c1和c2虽然具有相同的“值”，但是变量本身具有独立的内存地址。我们可以进一步看出四个变量的地址是“递减的”，这印证了一句话“</span><strong><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">栈往下生长、堆往上生长</span></strong><span class=\"ne-text\">”。</span></p><p id=\"u2e836de0\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image.tiff\" id=\"NBrWI\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/0.png\" width=\"310.6666666666667\" id=\"u80dfce93\" class=\"ne-image\"></p><h1 id=\"zJnwn\"><span class=\"ne-text\">二、变量的“值”</span></h1><p id=\"u1b799483\" class=\"ne-p\"><span class=\"ne-text\">对上面演示的这个例子来说，由于s1、c1、 s2和c2是依次定义的，所以它们对应的内存是连续的。不仅如此，我们还可以根据输出的地址计算出四个变量所占的内存大小。具体的布局如下，两个值类型的变量s1和s2占据16个字节，而两个引用类型的变量c1和c2则只占据8个字节。变量</span></p><p id=\"u950f0d29\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image%20(2).tiff\" id=\"dEdh6\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/1.png\" width=\"112.66666666666667\" id=\"u7e8de05f\" class=\"ne-image\"></p><div class=\"ne-quote\"><p id=\"uf655cf00\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">对于值类型来说，变量与其承载的内容是“一体”的，也就是说变量占据的内存存储的就是它承载的内容。</span><span class=\"ne-text\">也就是说s1和s2占据的16个字节存储的就是</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarStruct</span></code><span class=\"ne-text\">这个结构体的荷载内容。那么问题又来了，</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarStruct</span></code><span class=\"ne-text\">结构体包含的两个字段的类型分别是</span><code class=\"ne-code\"><span class=\"ne-text\">byte</span></code><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">long</span></code><span class=\"ne-text\">，对应的字节数分别是1和8，总字节数应该是9个字节才对，多出的7个字节是“内存地址对齐（</span><code class=\"ne-code\"><span class=\"ne-text\">Alignment</span></code><span class=\"ne-text\">）”造成的。由于要确保Bar字段基于8个字节的内存对齐，虽然</span><code class=\"ne-code\"><span class=\"ne-text\">Foo</span></code><span class=\"ne-text\">字段只需要使用一个字节，也需要添加7个空白字节。具体的内存布局请求参与相关的文档，在这里就不再赘述了。</span></p></div><div class=\"ne-quote\"><p id=\"u595eef7e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">对于引用类型来说，变量与其承载的内容则是“分离”的。引用类型的实例分配在堆上，对应的地址存储在变量占据的栈内存上。</span><span class=\"ne-text\">x64机器使用8个字节表示内存地址，所以c1和c2这两个变量只占据8个字节就很容易理解了。</span></p></div><p id=\"ud5082046\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image%20(3).tiff\" id=\"y5xXd\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/2.png\" width=\"210.66666666666666\" id=\"u23b47e56\" class=\"ne-image\"></p><p id=\"u19d1d603\" class=\"ne-p\"><span class=\"ne-text\">由于变量具有唯一的栈内存地址，其类型决定字节大小，所以</span><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">一个变量可以确定一段连续的栈内存空间</span><strong><span class=\"ne-text\">，我们在</span></strong><code class=\"ne-code\"><span class=\"ne-text\">Utility</span></code><strong><span class=\"ne-text\">类中定义了如下这个</span></strong><code class=\"ne-code\"><span class=\"ne-text\">Read</span></code><strong><span class=\"ne-text\">方法将这段</span></strong><span class=\"ne-text\">内存空间的字节内容**读取出来。如代码片段所示，我们通过调用</span><code class=\"ne-code\"><span class=\"ne-text\">Unsafe.SizeOf</span></code><span class=\"ne-text\">方法确定字节数量，并据此创建一个字节数组。通过上面定义的</span><code class=\"ne-code\"><span class=\"ne-text\">AsPointer</span></code><span class=\"ne-text\">方法得到变量的地址后，将其传入</span><code class=\"ne-code\"><span class=\"ne-text\">Marshal</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">Copy</span></code><span class=\"ne-text\">方法将字节内容拷贝到数组中。</span></p><pre data-language=\"csharp\" id=\"mwSPk\" class=\"ne-codeblock language-csharp\"><code>internal static class Utility\n{\n    public static unsafe byte[] Read&lt;T&gt;(ref T value)\n    {\n        byte[] bytes = new byte[Unsafe.SizeOf&lt;T&gt;()];\n        Marshal.Copy(AsPointer(ref value), bytes, 0, bytes.Length);\n        return bytes;\n    }\n}</code></pre><p id=\"ubc31f740\" class=\"ne-p\"><span class=\"ne-text\">在如下所示的演示程序中，我们依然按照上面的方式定义了四个变量并对它们进行了赋值，这次我们选择调用上面这个</span><code class=\"ne-code\"><span class=\"ne-text\">Read</span></code><span class=\"ne-text\">方法将四个变量的字节内容以16进制的形式打印出来。</span></p><pre data-language=\"csharp\" id=\"nmQ8H\" class=\"ne-codeblock language-csharp\"><code>var s1 = new FoobarStruct(255, 1);\nvar c1 = new FoobarClass(255, 1);\nvar s2 = s1;\nvar c2 = c1;\n\nConsole.WriteLine($&quot;s1: {BitConverter.ToString(Utility.Read(ref s1))}&quot;);\nConsole.WriteLine($&quot;c1: {BitConverter.ToString(Utility.Read(ref c1))}&quot;);\nConsole.WriteLine($&quot;s2: {BitConverter.ToString(Utility.Read(ref s2))}&quot;);\nConsole.WriteLine($&quot;c2: {BitConverter.ToString(Utility.Read(ref c2))}&quot;);</code></pre><p id=\"uc331944e\" class=\"ne-p\"><span class=\"ne-text\">从如下所示的输出结果可以看出，s1与s2，以及c1和c2承载的字节内容是完全一致的。s1和s2存储的正好是FoobarStruct的两个字段的内容，而且我们还看到了</span><code class=\"ne-code\"><span class=\"ne-text\">byte</span></code><span class=\"ne-text\">类型的</span><code class=\"ne-code\"><span class=\"ne-text\">Foo</span></code><span class=\"ne-text\">字段因“内存对齐”添加的7个空白字节（</span><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">FF-00-00-00-00-00-00-00</span><span class=\"ne-text\">）。</span></p><p id=\"u8e8cf213\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image%20(4).tiff\" id=\"YPEjx\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/3.png\" width=\"322\" id=\"ud0a2c61b\" class=\"ne-image\"></p><p id=\"uc021fda3\" class=\"ne-p\"><span class=\"ne-text\">虽然c1和c2具有相同的字节内容，又如何确定它们就是我们创建的</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarClass</span></code><span class=\"ne-text\">对象在堆上的内存地址呢？这也可以通过如下的程序来验证：我们创建了一个</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarClass</span></code><span class=\"ne-text\">对象，并将其赋值给变量</span><code class=\"ne-code\"><span class=\"ne-text\">value</span></code><span class=\"ne-text\">。我们调用</span><code class=\"ne-code\"><span class=\"ne-text\">Read</span></code><span class=\"ne-text\">方法确定该变量承载的8个字节，并调用</span><code class=\"ne-code\"><span class=\"ne-text\">BinaryPrimitives</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">ReadInt64LittleEndian</span></code><span class=\"ne-text\">方法（x86采用小端字节序）转换成</span><code class=\"ne-code\"><span class=\"ne-text\">long</span></code><span class=\"ne-text\">类型，</span><code class=\"ne-code\"><span class=\"ne-text\">然后</span></code><span class=\"ne-text\">进一步转换成</span><code class=\"ne-code\"><span class=\"ne-text\">IntPtr（nint）</span></code><span class=\"ne-text\">类型。指向</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarClass</span></code><span class=\"ne-text\">对象的指针可以通过调用</span><code class=\"ne-code\"><span class=\"ne-text\">Unsafe</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">AsPointer</span></code><span class=\"ne-text\">方法获得，我们通过“解指针”得到以</span><code class=\"ne-code\"><span class=\"ne-text\">IntPtr</span></code><span class=\"ne-text\">类型表示的内存地址。调式断言可以确认两个</span><code class=\"ne-code\"><span class=\"ne-text\">IntPtr</span></code><span class=\"ne-text\">对象的值是相等的。</span></p><pre data-language=\"csharp\" id=\"r4OTv\" class=\"ne-codeblock language-csharp\"><code>unsafe\n{  \n  var value = new FoobarClass(255, 1);  \n  var bytes = Utility.Read(ref value);  \n  var pointer1 = new nint(BinaryPrimitives.ReadInt64LittleEndian(bytes));  \n  var pointer2 = *(nint*)Unsafe.AsPointer(ref value);  \n  Debug.Assert(pointer1 == pointer2);\n}</code></pre><h1 id=\"XSIze\"><span class=\"ne-text\">三、常规参数的传递</span></h1><p id=\"uf0799559\" class=\"ne-p\"><span class=\"ne-text\">对于值类型和引用类型在参数传递过程中的差异，如果我们了解了变量的本质，就很好理解了。</span></p><div class=\"ne-quote\"><p id=\"u9e19546d\" class=\"ne-p\"><span class=\"ne-text\">两者直接的差异是“没有差异”——当我们将一个变量作为参数传递给某个方法时，传递的总是变量对应的栈内存存储的内容。</span></p></div><div class=\"ne-quote\"><p id=\"u5f8f61db\" class=\"ne-p\"><strong><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">对于值类型，传递的就是实例本身的内容；对于引用类型，传递的就是实例的地址。</span></strong></p></div><pre data-language=\"csharp\" id=\"oaHF4\" class=\"ne-codeblock language-csharp\"><code>var s = new FoobarStruct(255, 1);\nvar c = new FoobarClass(255, 1);\nInvoke(s, c);\nDebug.Assert(s.Foo == 255);\nDebug.Assert(s.Bar == 1);\nDebug.Assert(c.Foo == 0);\nDebug.Assert(c.Bar == 0);\n\nstatic void Invoke(FoobarStruct args, FoobarClass argc)\n{\n    args.Foo = 0;\n    args.Bar = 0;\n    argc.Foo = 0;\n    argc.Bar = 0;\n}</code></pre><p id=\"ub9d01114\" class=\"ne-p\"><span class=\"ne-text\">有了这个认识，对于如上这段代码表现出的针对两种类型参数传递的“差异”就不难理解了。如下面的代码片段所示，变量s、c以及</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke</span></code><span class=\"ne-text\">方法的参数</span><code class=\"ne-code\"><span class=\"ne-text\">args</span></code><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">argc</span></code><span class=\"ne-text\">都被分配到栈内存上，虽然s与</span><code class=\"ne-code\"><span class=\"ne-text\">args</span></code><span class=\"ne-text\">，c与</span><code class=\"ne-code\"><span class=\"ne-text\">argc</span></code><span class=\"ne-text\">具有相同的内容，但是针对</span><code class=\"ne-code\"><span class=\"ne-text\">args</span></code><span class=\"ne-text\">的操作将不会对s造成影响，但是针对c和</span><code class=\"ne-code\"><span class=\"ne-text\">argc</span></code><span class=\"ne-text\">的操作最终作用在引用的</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarClass</span></code><span class=\"ne-text\">对象上。</span></p><p id=\"u8d843cdc\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image%20(5).tiff\" id=\"CeJcT\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/4.png\" width=\"286.6666666666667\" id=\"ufafa5222\" class=\"ne-image\"></p><p id=\"u2700c142\" class=\"ne-p\"><span class=\"ne-text\">变量与参数具有不同的内存地址可以通过如下的程序来验证：我们定义了类型分别为</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarStruct</span></code><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarClass</span></code><span class=\"ne-text\">的两个变量s和c，并将其内存地址打印出来。两个变量作为参数传入</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke</span></code><span class=\"ne-text\">方法中，后者将参数的内存地址打印出来。</span></p><pre data-language=\"csharp\" id=\"jHgcj\" class=\"ne-codeblock language-csharp\"><code>var s = new FoobarStruct(255, 1);\nvar c = new FoobarClass(255, 1);\nConsole.WriteLine($&quot;s   : {Utility.AsPointer(ref s)}&quot;);\nConsole.WriteLine($&quot;c   : {Utility.AsPointer(ref c)}&quot;);\nInvoke(s, c);\nstatic void Invoke(FoobarStruct args, FoobarClass argc)\n{\n    Console.WriteLine($&quot;args: {Utility.AsPointer(ref args)}&quot;);\n    Console.WriteLine($&quot;argc: {Utility.AsPointer(ref argc)}&quot;);\n}</code></pre><p id=\"u41962880\" class=\"ne-p\"><span class=\"ne-text\">输出结果如下，可以看出变量和对应的参数具有完全不同的内存地址。</span></p><p id=\"u19023899\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image%20(6).tiff\" id=\"B6Paf\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/5.png\" width=\"282\" id=\"ucc04238d\" class=\"ne-image\"></p><h1 id=\"tkJ6F\"><span class=\"ne-text\">四、ref参数的传递</span></h1><p id=\"ua805c574\" class=\"ne-p\"><span class=\"ne-text\">我们都知道如果方法需要对原始值类型变量进行修改，就需要使用</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">关键来修饰对应的参数。对于上面定义的</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke</span></code><span class=\"ne-text\">方法，如果我们在</span><code class=\"ne-code\"><span class=\"ne-text\">FoobarStruct</span></code><span class=\"ne-text\">类型的参数</span><code class=\"ne-code\"><span class=\"ne-text\">args</span></code><span class=\"ne-text\">上添加了</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">关键字，变量s表示的结构体就可以在这个方法中被修改了。</span></p><pre data-language=\"csharp\" id=\"C1FIq\" class=\"ne-codeblock language-csharp\"><code>var s = new FoobarStruct(255, 1);\nvar c = new FoobarClass(255, 1);\nInvoke(ref s, ref c);\nDebug.Assert(s.Foo == 0);\nDebug.Assert(s.Bar == 0);\nDebug.Assert(c.Foo == 0);\nDebug.Assert(c.Bar == 0);\n\nstatic void Invoke(ref FoobarStruct args, ref FoobarClass argc)\n{\n    args.Foo = 0;\n    args.Bar = 0;\n    argc.Foo = 0;\n    argc.Bar = 0;\n}</code></pre><p id=\"ua053b31b\" class=\"ne-p\"><span class=\"ne-text\">对于值类型</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数的作用，几乎所有人都能够理解，但是我发现很多人理解不了引用类型的</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数。在他们眼中，引用类型的参数传递的就是对象的引用，加上</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">关键有什么意义呢？值类型和引用类型的</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数究竟有什么区别呢？</span></p><div class=\"ne-quote\"><p id=\"u2daed24f\" class=\"ne-p\"><span class=\"ne-text\">答案同样是“</span><strong><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">没有区别</span></strong><span class=\"ne-text\">”，因为它们传递的就是</span><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">变量自身的地址</span><span class=\"ne-text\">罢了（如下所示）。</span></p></div><p id=\"u8d277f66\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image%20(7).tiff\" id=\"Q0EAp\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/6.png\" width=\"324.6666666666667\" id=\"ub9cd724c\" class=\"ne-image\"></p><p id=\"ufbf1eb2b\" class=\"ne-p\"><span class=\"ne-text\">由于值类型变量和承载内容的“同一性”，所以我们自然可以利用</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数修改变量承载的实例；引用类型存储的是对象的内存地址，那么我们不仅仅可以通过</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数修改目标对象，我们还可以按照如下的方式</span><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">让变量指向另一个对象</span><span class=\"ne-text\">。当然值类型</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数也可以采用相同指定一个全新的值赋予变量。</span></p><pre data-language=\"csharp\" id=\"HtppL\" class=\"ne-codeblock language-csharp\"><code>var c = new FoobarClass(255, 1);\nvar original = c;\nInvoke(ref c);\nDebug.Assert(!ReferenceEquals(original, c));\nDebug.Assert(c.Foo == 0);\nDebug.Assert(c.Bar == 0);\nstatic void Invoke(ref FoobarClass argc)\n{\n    argc = new FoobarClass(0, 0);\n}</code></pre><p id=\"u34d2e6f1\" class=\"ne-p\"><span class=\"ne-text\">变量和对应的</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数具有相同的内存地址，这可以通过如下这段程序来证明。</span></p><pre data-language=\"csharp\" id=\"y8S8p\" class=\"ne-codeblock language-csharp\"><code>var s = new FoobarStruct(255, 1);\nvar c = new FoobarClass(255, 1);\n\nConsole.WriteLine($&quot;s   : {Utility.AsPointer(ref s)}&quot;);\nConsole.WriteLine($&quot;c   : {Utility.AsPointer(ref c)}&quot;);\nInvoke(ref s, ref c);\n\nstatic void Invoke(ref FoobarStruct args, ref FoobarClass argc)\n{\n    Console.WriteLine($&quot;args: {Utility.AsPointer(ref args)}&quot;);\n    Console.WriteLine($&quot;argc: {Utility.AsPointer(ref argc)}&quot;);\n}</code></pre><p id=\"u328257ba\" class=\"ne-p\"><span class=\"ne-text\">输出结果：</span></p><p id=\"uabf39600\" class=\"ne-p\"><img src=\"C#-%E5%80%BC%E7%B1%BB%E5%9E%8Bvs%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.assets/Image%20(8).tiff\" id=\"MyrWO\" class=\"ne-image\"><img src=\"https://file.cadengao.com/assets/doc/54197715.182315379/image/7.png\" width=\"262.6666666666667\" id=\"u46a7a7bb\" class=\"ne-image\"></p><p id=\"u8943e4ae\" class=\"ne-p\"><span class=\"ne-text\">值得一提的是，如果我们在方法（比如下面的</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke1</span></code><span class=\"ne-text\">）中将ref参数直接赋值给另一个变量，此时又出现了拷贝。如果希望让</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数和变量指向相同的内存地址，需要按照</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke2</span></code><span class=\"ne-text\">方法那样同时在变量和参数上添加</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">关键字。</span></p><pre data-language=\"csharp\" id=\"otZS3\" class=\"ne-codeblock language-csharp\"><code>var s = new FoobarStruct(255, 1);\n\nInvoke1(ref s);\nDebug.Assert(s.Foo == 255);\nDebug.Assert(s.Bar == 1);\n\nInvoke2(ref s);\nDebug.Assert(s.Foo == 0);\nDebug.Assert(s.Bar == 0);\nstatic void Invoke1(ref FoobarStruct args)\n{\n    var s = args;\n    s.Foo = 0;\n    s.Bar = 0;\n}\n\nstatic void Invoke2(ref FoobarStruct args)\n{\n    ref var s = ref args;\n    s.Foo = 0;\n    s.Bar = 0;\n}</code></pre><h1 id=\"i1eR8\"><span class=\"ne-text\">五、in/out参数</span></h1><p id=\"ud013f452\" class=\"ne-p\"><span class=\"ne-text\">由于</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数赋予了方法“替换”原始变量的权力，这往往不是调用者希望的，此时就可以使用</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">关键字。</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">参数和</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数在传递变量地址这方面是完全一致的，所以方法可以利用</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">参数修改原始变量的成员，但是类似于下面这种直接替换变量的行为是不支持的，</span><strong><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">将一个</span></strong><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">in</span></code><strong><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">参数以</span></strong><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">ref</span></code><strong><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">参数的形式赋值给一个</span></strong><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">ref</span></code><strong><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">变量也是不允许的</span></strong><span class=\"ne-text\">。通过</span><code class=\"ne-code\"><span class=\"ne-text\">out</span></code><span class=\"ne-text\">关键字定义的输出参数和</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数一样也是传递变量地址，也正是因为这样，方法才能通过参数赋值的方式将其传递给调用者。</span></p><pre data-language=\"csharp\" id=\"OAM9m\" class=\"ne-codeblock language-csharp\"><code>static void Invoke1(in FoobarStruct args)\n{\n    args = new FoobarStruct(0, 0);\n}\n\nstatic void Invoke2(in FoobarStruct args)\n{\n    ref var s = ref args;\n}</code></pre><p id=\"u160eb6e7\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数赋予了被调用方法直接修改或者替换原始变量的能力，那么如果我们没有这方面的需求，</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数是否就无用武之地了呢？当然不是，</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数可以避免针对值类型对象的拷贝，如果我们定义了一个较大的结构体，针对该结构体的参数传递将会导致大量的字节拷贝，如果我们使用</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数，传递的字节总是固定的4个（x86）或者8个字节（x64）。</span></p><p id=\"ub00db691\" class=\"ne-p\"><span class=\"ne-text\">我们从</span><code class=\"ne-code\"><span class=\"ne-text\">IL</span></code><span class=\"ne-text\">代码的角度进一步探索常规参数传递和三种基于引用的参数传递，为此我们定义了如下这段简单的程序。如代码片段所示，</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke</span></code><span class=\"ne-text\">方法定义了6个参数，</span><code class=\"ne-code\"><span class=\"ne-text\">arg</span></code><span class=\"ne-text\">、</span><code class=\"ne-code\"><span class=\"ne-text\">inArg</span></code><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">refArg</span></code><span class=\"ne-text\">分别为常规参数、</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">参数和</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">参数，我们将它们赋值给三个对应的</span><code class=\"ne-code\"><span class=\"ne-text\">out</span></code><span class=\"ne-text\">参数。</span></p><pre data-language=\"csharp\" id=\"eQWUe\" class=\"ne-codeblock language-csharp\"><code>var (arg1, arg2, arg3) = (1,1,1);\nInvoke(arg1, in arg2, ref arg3, out var outArg1, out var outArg2, out var outArg3);\n\nstatic void Invoke(int arg, in int inArg, ref int refArg, out int outArg1, out int outArg2, out int outArg3)\n{\n    outArg1 = arg;\n    outArg2 = inArg;\n    outArg3 = refArg;\n}</code></pre><p id=\"ua3df6851\" class=\"ne-p\"><span class=\"ne-text\">如下所示的是</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke</span></code><span class=\"ne-text\">方法对应的</span><code class=\"ne-code\"><span class=\"ne-text\">IL</span></code><span class=\"ne-text\">代码。看出虽然6个参数在</span><code class=\"ne-code\"><span class=\"ne-text\">C#</span></code><span class=\"ne-text\">中的类型都是</span><code class=\"ne-code\"><span class=\"ne-text\">Int32</span></code><span class=\"ne-text\">，但是标注了</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">out</span></code><span class=\"ne-text\">关键子的参数类型在</span><code class=\"ne-code\"><span class=\"ne-text\">IL</span></code><span class=\"ne-text\">中变成了</span><code class=\"ne-code\"><span class=\"ne-text\">int32&amp;</span></code><span class=\"ne-text\">。由于</span><code class=\"ne-code\"><span class=\"ne-text\">inArg</span></code><span class=\"ne-text\">和</span><code class=\"ne-code\"><span class=\"ne-text\">refArg</span></code><span class=\"ne-text\">存储的是变量的地址，所以在利用</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"color: rgb(255, 111, 4)\">ldarg.{index}</span></code><span class=\"ne-text\">指令将对应参数压入栈后，还需要进一步执行</span><code class=\"ne-code\"><span class=\"ne-text\">ldind.i4</span></code><span class=\"ne-text\">指令提取具体的值。</span></p><pre data-language=\"plain\" id=\"s20Uu\" class=\"ne-codeblock language-plain\"><code>.method assembly hidebysig static\n    void '&lt;&lt;Main&gt;$&gt;g__Invoke|0_0' (\n        int32 arg,\n        [in] int32&amp; inArg,\n        int32&amp; refArg,\n        [out] int32&amp; outArg1,\n        [out] int32&amp; outArg2,\n        [out] int32&amp; outArg3\n    ) cil managed\n{\n    .custom instance void [System.Runtime]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (\n        01 00 00 00\n    )\n    .param [2]\n        .custom instance void [System.Runtime]System.Runtime.CompilerServices.IsReadOnlyAttribute::.ctor() = (\n            01 00 00 00\n        )\n    // Method begins at RVA 0x269e\n    // Header size: 1\n    // Code size: 15 (0xf)\n    .maxstack 8\n\n    // {\n    IL_0000: nop\n    // outArg1 = arg;\n    IL_0001: ldarg.3\n    IL_0002: ldarg.0\n    IL_0003: stind.i4\n    // outArg2 = inArg;\n    IL_0004: ldarg.s outArg2\n    IL_0006: ldarg.1\n    IL_0007: ldind.i4\n    IL_0008: stind.i4\n    // outArg3 = refArg;\n    IL_0009: ldarg.s outArg3\n    IL_000b: ldarg.2\n    IL_000c: ldind.i4\n    IL_000d: stind.i4\n    // }\n    IL_000e: ret\n} // end of method Program::'&lt;&lt;Main&gt;$&gt;g__Invoke|0_0'</code></pre><p id=\"u7b2448cb\" class=\"ne-p\"><span class=\"ne-text\">如下所示的</span><code class=\"ne-code\"><span class=\"ne-text\">IL</span></code><span class=\"ne-text\">代码体现了针对</span><code class=\"ne-code\"><span class=\"ne-text\">Invoke</span></code><span class=\"ne-text\">方法的调用。在对传入参数进行压栈过程中，对于第一个常规参数</span><code class=\"ne-code\"><span class=\"ne-text\">arg</span></code><span class=\"ne-text\">，会执行</span><code class=\"ne-code\"><span class=\"ne-text\">ldloc.{index}</span></code><span class=\"ne-text\">加载变量的值。至于其余5个基于引用/地址的参数，则需要执行</span><code class=\"ne-code\"><span class=\"ne-text\">ldloca.{index}</span></code><span class=\"ne-text\">加载变量的地址。</span></p><pre data-language=\"plain\" id=\"xltr8\" class=\"ne-codeblock language-plain\"><code>.method private hidebysig static\n    void '&lt;Main&gt;$' (\n        string[] args\n    ) cil managed\n{\n    // Method begins at RVA 0x2670\n    // Header size: 12\n    // Code size: 25 (0x19)\n    .maxstack 6\n    .entrypoint\n    .locals init (\n        [0] int32 arg1,\n        [1] int32 arg2,\n        [2] int32 arg3,\n        [3] int32 outArg1,\n        [4] int32 outArg2,\n        [5] int32 outArg3\n    )\n\n    // int arg2 = 1;\n    IL_0000: ldc.i4.1\n    IL_0001: stloc.0\n    // int inArg2 = 1;\n    IL_0002: ldc.i4.1\n    IL_0003: stloc.1\n    // int refArg2 = 1;\n    IL_0004: ldc.i4.1\n    IL_0005: stloc.2\n    // Invoke(arg2, in inArg2, ref refArg2, out var _, out var _, out var _);\n    IL_0006: ldloc.0\n    IL_0007: ldloca.s 1\n    IL_0009: ldloca.s 2\n    IL_000b: ldloca.s 3\n    IL_000d: ldloca.s 4\n    IL_000f: ldloca.s 5\n    IL_0011: call void Program::'&lt;&lt;Main&gt;$&gt;g__Invoke|0_0'(int32, int32&amp;, int32&amp;, int32&amp;, int32&amp;, int32&amp;)\n    // (no C# code)\n    IL_0016: nop\n    // }\n    IL_0017: nop\n    IL_0018: ret\n} // end of method Program::'&lt;Main&gt;$'</code></pre><h1 id=\"yJ19W\"><span class=\"ne-text\">六、总结</span></h1><p id=\"ua1071916\" class=\"ne-p\"><span class=\"ne-text\">我们最后通过一个简单的类比来做一个总结。变量的目的在于传递信息，假设我们现在利用一个“盒子”来传递一幅世界名画，这个盒子就是变量，对于非引用性质的传递（作为方法参数，或者赋值给另一个变量），传递的都是盒子承载内容的拷贝。</span></p><div class=\"ne-quote\"><p id=\"uea7d4151\" class=\"ne-p\"><span class=\"ne-text\">如果是值类型，我们相当于我们将这幅画作“真迹”放到盒子中，所以传递的是这副画作的复制品，我们在复制品上所作的任何涂鸦自然不会对真迹造成影响。</span></p></div><div class=\"ne-quote\"><p id=\"ud5b5ae3f\" class=\"ne-p\"><span class=\"ne-text\">如果是引用类型，我们相当于将真迹存放到保险柜中，将保险柜的编号放到盒子中，那么我们每次从盒子中取出来的是这个编号的复制品，但是系统会自动根据这个编号从所在保险柜中的真迹供你欣赏，如果你想涂鸦的话，就真的毁了这副名画。</span></p></div><p id=\"u2a38d524\" class=\"ne-p\"><span class=\"ne-text\">如果采用基于引用的传递（使用</span><code class=\"ne-code\"><span class=\"ne-text\">in</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\">/</span><code class=\"ne-code\"><span class=\"ne-text\">out</span></code><span class=\"ne-text\">参数，或者针对</span><code class=\"ne-code\"><span class=\"ne-text\">ref</span></code><span class=\"ne-text\"> 变量的赋值），相当于我们直接得到了这个盒子。对于值类型，意味着我们得到的也是真迹。不仅如此，我们还可以直接利用一副伪作将其掉包了。如果是值类型，相当于我们将盒子中的真迹换成了赝品。对于引用类型，我们先将赝品放在另一个保险柜中，将盒子中编号替换成这个保险柜的编号。</span></p></div>"
}