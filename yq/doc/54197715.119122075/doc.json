{
  "uuid": "54197715.119122075",
  "id": 119122075,
  "title": "C#-CLR、内存分配和内存回收【Area】",
  "cover": "https://cdn.nlark.com/yuque/0/2023/png/123299/1679488241743-0c7bdb95-2eef-4ee4-a69a-47a32f38e1b8.png",
  "book_id": 54197715,
  "book_name": "Area",
  "public": 0,
  "word_count": 4503,
  "created_at": "2023-03-22T12:29:01",
  "updated_at": "2024-08-17T03:29:32",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h1 id=\"J52mW\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">CLR</span></h1><p id=\"uf606c620\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">CLR：即公共语言运行时(Common Language Runtime)，是中间语言（IL）的运行时环境，负责将编译生成的MSIL编译成计算机可以识别的机器码，负责资源管理（内存分配和垃圾回收等）。</span></p><p id=\"u85292dd9\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/0.png\" width=\"1142\" id=\"u70187aca\" class=\"ne-image\"></p><p id=\"u6ddb01f1\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">可能有人会提问：为什么不直接编译成机器码，而要先编译成IL，然后在编译成机器码呢？</span></p><p id=\"u8352e5b4\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">原因是：计算机的操作系统不同（分为32位和64位），接受的计算机指令也是不同的，在不同的操作系统中就要进行不同的编译，写出的代码在不同的操作系统中要进行不同的修改。中间增加了IL层，不管是什么操作系统，编译生成的IL都是相同的，IL被不同操作系统的CLR编译成机器码，最终被计算机执行。</span></p><p id=\"u3d3d422c\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">JIT：即时编译器，负责编译成机器码。</span></p><h1 id=\"CmQAP\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">内存分配</span></h1><p id=\"u3a80e2ea\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">内存分配：指程序运行时，进程占用的内存，由CLR负责分配。</span></p><p id=\"ucc8c5d66\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">值类型：值类型是struct的，例如：int、datetime等。</span></p><p id=\"u95240dab\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">引用类型：即class，例如：类、接口，string等。</span></p><ol data-index-type=\"1\" class=\"ne-ol\"><li id=\"ub3480045\" data-lake-index-type=\"1\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 栈</span></li></ol><p id=\"u94b5d680\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">栈：即线程栈，先进后出的一种数据结构，随着线程而分配，其顺序如下：</span></p><p id=\"u2ddbf6a6\" class=\"ne-p\" style=\"text-align: left\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/1.png\" width=\"365\" id=\"ud7a26f73\" class=\"ne-image\"></p><p id=\"u2bfc133e\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">看下面的例子：</span></p><p id=\"u4d62725a\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">定义一个结构类型</span></p><pre data-language=\"csharp\" id=\"wcCaV\" class=\"ne-codeblock language-csharp\"><code>public struct ValuePoint\n{\n    public int x;\n    public ValuePoint(int x)\n    {\n         this.x = x;\n    }\n}</code></pre><p id=\"u6b5f506d\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在方法里面调用：</span></p><pre data-language=\"csharp\" id=\"LIqMq\" class=\"ne-codeblock language-csharp\"><code>//先声明变量，没有初始化  但是我可以正常赋值  跟类不同\nValuePoint valuePoint;\nvaluePoint.x = 123;\n\nValuePoint point = new ValuePoint();\nConsole.WriteLine(valuePoint.x);</code></pre><p id=\"u57034b65\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">内存分配情况如下图所示：</span></p><p id=\"u4b224b8e\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/2.png\" width=\"160\" id=\"uc27c5aeb\" class=\"ne-image\"></p><p id=\"uf02f08e2\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注意：</span></p><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"ub5b36fd0\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">值类型分配在线程栈上面，变量和值都是在线程栈上面。</span></li><li id=\"u5b00fe1b\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">值类型可以先声明变量而不用初始化。</span></li></ol><ol start=\"2\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"u74699d70\" data-lake-index-type=\"1\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">堆</span></li></ol><p id=\"u1f52aa78\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">堆：对象堆，是进程中独立划出来的一块内存，有时一些对象需要长期使用不释放、对象的重用，这些对象就需要放到堆上。</span></p><p id=\"u3c5df126\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">来看下面的例子：</span></p><p id=\"ufb1d3e42\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">定义一个类</span></p><pre data-language=\"csharp\" id=\"qoVPN\" class=\"ne-codeblock language-csharp\"><code>public class ReferencePoint\n{\n     public int x;\n     public ReferencePoint(int x)\n     {\n           this.x = x;\n     }\n}</code></pre><p id=\"u6aac112b\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在代码中调用：</span></p><pre data-language=\"csharp\" id=\"TgMek\" class=\"ne-codeblock language-csharp\"><code>ReferencePoint referencePoint = new ReferencePoint(123);\nConsole.WriteLine(referencePoint.x);</code></pre><p id=\"ubfa3cac7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"> 其内存分配如下：</span></p><p id=\"u5e68f64d\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/3.png\" width=\"651\" id=\"u8da73bd1\" class=\"ne-image\"></p><p id=\"u7ee62788\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注意：</span></p><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"ub9df57fa\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">引用类型分配在堆上面，变量在栈上面，值在堆上面。</span></li><li id=\"ub6c17ee8\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">引用类型分配内存的步骤：</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"u87252b5f\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">new的时候去对象堆里面开辟一块内存，分配一个内存地址。</span></li><li id=\"ufb462c88\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">调用构造函数(因为在构造函数里面可以使用this)，这时才执行构造函数。</span></li><li id=\"u1f99382f\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">把地址引用传给栈上面的变量。</span></li></ol></ol><ol start=\"3\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"u48904216\" data-lake-index-type=\"1\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">复杂类型</span></li></ol><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u67d84ae6\" data-lake-index-type=\"2\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">引用类型里面嵌套值类型</span></li></ol><p id=\"u85a1d18b\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">先看下面引用类型的定义：</span></p><pre data-language=\"csharp\" id=\"HjCw4\" class=\"ne-codeblock language-csharp\"><code>public class ReferenceTypeClass\n{\n\tprivate int _valueTypeField;\n\tpublic ReferenceTypeClass()\n\t{\n\t    _valueTypeField = 0;\n\t}\n\tpublic void Method()\n\t{\n\t    int valueTypeLocalVariable = 0;\n\t}\n}</code></pre><p id=\"uf678cc99\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在一个引用类型里面定义了一个值类型的属性：_valueTypeField和一个值类型的局部变量：valueTypeLocalVariable，那么这两个值类型是如何进行内存分配的呢？其内存分配如下：</span></p><p id=\"ud64070fb\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/5.png\" width=\"1142\" id=\"u2006a390\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"u03e69d6a\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">内存分配为什么是这种情况呢？值类型不应该是都分配在栈上面吗？为什么一个是分配在堆上面，一个是分配在栈上面呢？</span></p><p id=\"ua6e69903\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">_valueTypeField分配在堆上面比较好理解，因为引用类型是在堆上面分配了一整块内存，引用类型里面的属性也是在堆上面分配内存。</span></p><p id=\"u0297479a\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">valueTypeLocalVariable分配在栈上面是因为valueTypeLocalVariable是一个全新的局部变量，调用方法的时候，会启用一个线程去调用，线程栈来调用方法，然后把局部变量分配到栈上面。</span></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u458d3bc8\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">值类型里面嵌套引用类型</span></li></ol><p id=\"u07e9a839\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">先来看看值类型的定义：</span></p><pre data-language=\"csharp\" id=\"VTUOy\" class=\"ne-codeblock language-csharp\"><code>public struct ValueTypeStruct\n{\n    private object _referenceTypeField;\n    public ValueTypeStruct(int x)\n    {\n        _referenceTypeField = new object();\n    }\n    public void Method()\n    {\n        object referenceTypeLocalVariable = new object();\n    }\n}</code></pre><p id=\"ue745b0e3\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在值类型里面定义了引用类型，其内存是如何分配的呢？其内存分配如下：</span></p><p id=\"u7c019788\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/4.png\" width=\"1169\" id=\"ucd83dff5\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"u295c2e9d\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">从上面的截图中可以看出：值类型里面的引用类型的变量分配在栈上，值分配在堆上。</span></p><p id=\"u6e4af351\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">总结：</span></p><ol class=\"ne-ol\"><li id=\"u47b9775c\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">方法的局部变量</span></li></ol><p id=\"u12ec4565\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">根据变量自身的类型决定，与所在的环境没关系。变量如果是值类型，就分配在栈上。变量如果是引用类型，内存地址的引用存放在栈上，值存放在堆上。</span></p><ol start=\"2\" class=\"ne-ol\"><li id=\"ucb7ae829\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">对象是引用类型</span></li></ol><p id=\"u528345eb\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">其属性/字段，都是在堆上分配内存。</span></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ub6ed8f60\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">对象是值类型</span></li></ol><p id=\"u6c66f0d7\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">其属性/字段由自身的类型决定。属性/字段是值类型就分配在栈上；属性/字段是引用类型就分配在堆上。</span></p><p id=\"ubcaa01ae\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">上面的三种情况可以概括成下面一句话：</span></p><p id=\"udd0f9cb1\" class=\"ne-p\" style=\"text-align: left\"><strong><span class=\"ne-text\" style=\"color: #DF2A3F; font-size: 14px\">引用类型在任何时候都是分配在堆上；值类型任何时候都是分配在栈上，除非值类型是在引用类型里面。</span></strong></p><ol start=\"4\" class=\"ne-ol\"><li id=\"u3ad2f389\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">String字符串的内存分配</span></li></ol><p id=\"u8c6ac7a9\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">首先要明确一点：string是引用类型。</span></p><p id=\"u4d4b749f\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">先看看下面的例子：</span></p><pre data-language=\"csharp\" id=\"snxJ1\" class=\"ne-codeblock language-csharp\"><code>string student = &quot;大山&quot;;//在堆上面开辟一块儿内存  存放“大山”  返还一个引用（student变量）存放在栈上</code></pre><p id=\"u86d3b5ad\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">其内存分配如下图所示：</span></p><p id=\"ucceac65a\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/6.png\" width=\"655\" id=\"u7383b3b2\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"u7c984fe1\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">这时，在声明一个变量student2，然后用student给student2赋值：</span></p><pre data-language=\"csharp\" id=\"ZOhJc\" class=\"ne-codeblock language-csharp\"><code>string student2 = student;</code></pre><p id=\"u547170a6\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">这时内存是如何分配的呢？其内存分配如下：</span></p><p id=\"uf206e400\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/7.png\" width=\"657\" id=\"u38784541\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"ua9772715\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">从上面的截图中可以看出：student2被student赋值的时候，是在栈上面复制一份student的引用给student2，然后student和student2都是指向堆上面的同一块内存。</span></p><p id=\"uff3e00a2\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">输出student和student2的值：</span></p><pre data-language=\"csharp\" id=\"q2A4F\" class=\"ne-codeblock language-csharp\"><code>Console.WriteLine(&quot;student的值是：&quot; + student);\nConsole.WriteLine(&quot;student2的值是：&quot;+student2);</code></pre><p id=\"u43420971\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">结果：</span></p><p id=\"u61d5e49e\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/8.png\" width=\"980\" id=\"u167a01c3\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"ue184b888\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">从结果可以看出：student和student2的值是一样的，这也能说明student和student2指向的是同一块内存。</span></p><p id=\"ub3cb2900\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">这时修改student2的值：</span></p><pre data-language=\"csharp\" id=\"libZq\" class=\"ne-codeblock language-csharp\"><code>student2 = &quot;App&quot;;</code></pre><p id=\"uae679dc3\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">这时在输出student和student2的值，其结果如下图所示：</span></p><p id=\"uf317993e\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/9.png\" width=\"978\" id=\"u6c7c77cd\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"ucae552ff\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">从结果中可以看出：student的值保持不变，student2的值变为App，为什么是这样呢？这是因为string字符串的不可变性造成的。一个string变量一旦声明并初始化以后，其在堆上面分配的值就不会改变了。这时修改student2的值，并不会去修改堆上面分配的值，而是重新在堆上面开辟一块内存来存放student2修改后的值。修改后的内存分配如下：</span></p><p id=\"u15b4065c\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/10.png\" width=\"660\" id=\"u815b4f2b\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"u702f64a0\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在看下面一个例子：</span></p><pre data-language=\"csharp\" id=\"Ivivf\" class=\"ne-codeblock language-csharp\"><code>string student = &quot;大山&quot;; \nstring student2 = &quot;App&quot;; \nstudent2 = &quot;大山&quot;; \nConsole.WriteLine(object.ReferenceEquals(student,student2));</code></pre><p id=\"ua61cb81e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">结果：</span></p><p id=\"u507b2fdd\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/11.png\" width=\"977\" id=\"u8edc01d0\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"ue5abb8a0\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">可能有人会想：按照上面讲解的，student和student2应该指向的是不同的内存地址，结果应该是false啊，为什么会是true呢？这是因为CLR在分配内存的时候，会查找是否有相同的值，如果有相同的值，就重用；如果没有，这时在重新开辟一块内存。所以修改student2以后，student和student2都是指向同一块内存，结果输出是true。</span></p><p id=\"u9ddeaceb\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注意：</span></p><p id=\"u7524c2d9\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">这里需要区分string和其他引用类型的内存分配。其他引用类型的情况和string正好相反。看下面的例子</span></p><p id=\"u9ecd5129\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">先定义一个Refence类，里面有一个int类型的属性，类定义如下：</span></p><pre data-language=\"csharp\" id=\"M1cfM\" class=\"ne-codeblock language-csharp\"><code>public class Refence \n{ \n\tpublic int Value { get; set; }\n}</code></pre><p id=\"uad05e981\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在Main()方法里面调用：</span></p><pre data-language=\"csharp\" id=\"em6LR\" class=\"ne-codeblock language-csharp\"><code>Refence r1 = new Refence();\nr1.Value = 30;\nRefence r2 = r1;\nConsole.WriteLine($&quot;r2.Value的值:{r2.Value}&quot;);\nr2.Value = 50;\nConsole.WriteLine($&quot;r1.Value的值:{r1.Value}&quot;);\nConsole.ReadKey();</code></pre><p id=\"u9e4d86d2\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></span></p><p id=\"u77f65ef7\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">结果：</span></p><p id=\"u14f1ee66\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/12.png\" width=\"979\" id=\"u4ef9473b\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><p id=\"u4843b00d\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">从运行结果可以看出，如果是普通的引用类型，如果修改其他一个实例的值，那么另一个实例的值也会改变。正好与string类型相反。</span></p><h1 id=\"dem1J\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">内存回收</span></h1><p id=\"uf52ed9c5\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">值类型存放在线程栈上，线程栈是每次调用都会产生，用完自己就会释放。</span></p><p id=\"u7b2b401c\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">引用类型存放在堆上面，全局共享一个堆，空间有限，所以才需要垃圾回收。</span></p><p id=\"u9457d1a1\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">CLR在堆上面是连续分配内存的。</span></p><ol data-index-type=\"1\" class=\"ne-ol\"><li id=\"uba06533e\" data-lake-index-type=\"1\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">C#中的资源分为两类：</span></li></ol><ol class=\"ne-ol\"><li id=\"u6ba4c8c7\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">托管资源</span></li></ol><p id=\"u26aa213b\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">由CLR管理的存在于托管堆上的称为托管资源，注意这里有2个关键点，第一是由CLR管理，第二存在于托管堆上。托管资源的回收工作是不需要人工干预的，CLR会在合适的时候调用GC(垃圾回收器)进行回收。</span></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u806f6857\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">非托管资源</span></li></ol><p id=\"u6a997ea4\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">非托管资源是不由CLR管理，例如：Image Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源（这里仅仅列举出几个常用的）。这些资源GC是不会自动回收的，需要手动释放。</span></p><ol start=\"2\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"u1ff9a1b5\" data-lake-index-type=\"1\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">托管资源</span></li></ol><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u35306129\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">垃圾回收期(GC)</span></li></ol><p id=\"uc3def1b2\" class=\"ne-p\" style=\"text-align: left; text-indent: 2em\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">定期或在内存不够时，通过销毁不再需要或不再被引用的对象，来释放内存，是CLR的一个重要组件。</span></p><ol start=\"2\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"ucc0fd94f\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">垃圾回收器销毁对象的两个条件</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"ufa8c3c7c\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">对象不再被引用----设置对象=null。</span></li><li id=\"uecd1f08c\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">对象在销毁器列表中没有被标记。</span></li></ol></ol><ol start=\"3\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"u3ab5b404\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">垃圾回收发生时机</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"uafe1837b\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">垃圾回收发生在new的时候，new一个对象时，会在堆中开辟一块内存，这时会查看内存空间是否充足，如果内存空间不够，则进行垃圾回收。</span></li><li id=\"uf02e98e7\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">程序退出的时候也会进行垃圾回收。</span></li></ol></ol><ol start=\"4\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"uc61536d0\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">垃圾回收期工作原理</span></li></ol><p id=\"uf33556d3\" class=\"ne-p\" style=\"text-align: left; text-indent: 2em\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">GC定期检查对象是否未被引用，如果对象没有被引用，则在检查销毁器列表。若在销毁器列表中没有标记，则立即回收。若在销毁器列表中有标记，则开启销毁器线程，由该线程调用析构函数，析构函数执行完，删除销毁器列表中的标记。</span></p><p id=\"ua4448b63\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注意：</span></p><p id=\"u96faa832\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">不建议写析构函数，原因如下：</span></p><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"u26f9dc53\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">对象即使不用，也会在内存中驻留很长一段时间。</span></li><li id=\"ud5f242c2\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">销毁器线程为单独的线程，非常耗费资源。</span></li></ol></ol><ol start=\"5\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"u59cff4ae\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">优化策略：分级策略</span></li></ol><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"ue4a57ce6\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">首次GC前 全部对象都是0级。</span></li><li id=\"u2b396f40\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">第一次GC后，还保留的对象叫1级。这时新创建的对象就是0级。</span></li><li id=\"u7c0314cb\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">垃圾回收时，先查找0级对象，如果空间还不够，再去找1级对象，这之后，还存在的一级对象就变成2级，0级对象就变成一级对象。</span></li><li id=\"udad36a9e\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">垃圾回收时如果0~2级都不够，那么就内存溢出了。</span></li></ol></ol><p id=\"u375c047f\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注意：</span></p><p id=\"ub1646d09\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">越是最近分配的，越是会被回收。因为最近分配的都是0级对象，每次垃圾回收时都是先查询0级对象。</span></p><p id=\"u96fdca71\" class=\"ne-p\" style=\"text-align: center\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119122075/image/13.png\" width=\"709\" id=\"u3a093794\" class=\"ne-image\" style=\"color: rgb(51, 51, 51); font-size: 14px\"></p><ol start=\"3\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"u37458e76\" data-lake-index-type=\"1\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">非托管资源</span></li></ol><p id=\"ue5dff1d6\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">上面讲的都是针对托管资源的，托管资源会被GC回收，不需要考虑释放。但是，垃圾回收器不知道如何释放非托管的资源（例如，文件句柄、网络连接和数据库连接）。托管类在封装对非托管资源的直接或间接引用时，需要制定专门的规则，确保非托管的资源在回收类的一个实例时会被释放。</span></p><p id=\"u2c067208\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在定义一个类时，可以使用两种机制来自动释放非托管的资源。这些机制常常放在一起实现，因为每种机制都为问题提供了略为不同的解决方法。这两种机制是：</span></p><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" class=\"ne-ol\"><li id=\"ue9ed0c5e\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">声明一个析构函数(或终结器)，作为类的一个成员。</span></li><li id=\"u3ddf913a\" data-lake-index-type=\"0\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在类中实现System.IDisposable接口。</span></li></ol></ol><ol data-index-type=\"2\" class=\"ne-ol\"><li id=\"u2ee2021d\" data-lake-index-type=\"2\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">析构函数或终结器</span></li></ol><p id=\"ued3cb579\" class=\"ne-p\" style=\"text-align: left\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">析构函数看起来类似于一个方法：与包含的类同名，但有一个前缀波形符号(~)。它没有返回值，不带参数，也没有访问修饰符。看下面的一个例子：</span></p><pre data-language=\"csharp\" id=\"m1vEf\" class=\"ne-codeblock language-csharp\"><code>public class MyClass\n{\n\t/// &lt;summary&gt;\n\t/// 析构函数\n\t/// &lt;/summary&gt;\n\t~MyClass()\n\t{\n\t    // 要执行的代码\n\t}\n}</code></pre><p id=\"u325fb895\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">析构函数存在的问题：</span></p><ol class=\"ne-list-wrap\"><ol ne-level=\"1\" data-index-type=\"2\" class=\"ne-ol\"><li id=\"ub63815a7\" data-lake-index-type=\"2\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">由于使用C#时垃圾回收器的工作方式，无法确定C#对象的析构函数何时执行。所以，不能在析构函数中放置需要在某一时刻运行的代码，也不应该寄希望于析构函数会以特定顺序对不同类的实例调用。如果对象占用了宝贵而重要的资源，应尽快释放这些资源，此时就不能等待垃圾回收器来释放了。</span></li><li id=\"u5b4faa22\" data-lake-index-type=\"2\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">C#析构函数的实现会延迟对象最终从内存中删除的时间。没有析构函数的对象会在垃圾回收器的一次处理中从内存中删除，但有析构函数的对象需要两次处理才能销毁：第一次调用析构函数时，没有删除对象，第二次调用才真正删除对象。</span></li><li id=\"u0d7834cb\" data-lake-index-type=\"2\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">运行库使用一个线程来执行所有对象的Finalize()方法。如果频繁使用析构函数，而且使用它们执行长时间的清理任务，对性能的影响就会非常显著。</span></li></ol></ol><p id=\"u12655a44\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">注意：</span></p><p id=\"u989d9bf9\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在讨论C#中的析构函数时，在低层的.NET体系结构中，这些函数称为终结器(finalizer)。在C#中定义析构函数时，编译器发送给程序集的实际上是Finalize()方法，它不会影响源代码。C#编译器在编译析构函数时，它会隐式地把析构函数的代码编译为等价于重写Finalize()方法的代码，从而确保执行父类的Finalize()方法。例如，下面的C#代码等价于编译器为~MyClass()析构函数生成的IL：</span></p><pre data-language=\"csharp\" id=\"DTzdU\" class=\"ne-codeblock language-csharp\"><code>protected override void Finalize()\n{\n       try\n       {\n            // 析构函数中要执行的代码\n       }\n       finally\n       {\n            // 调用父类的Finalize()方法\n            base.Finalize();\n       }\n}</code></pre><ol start=\"2\" class=\"ne-ol\"><li id=\"ud283931b\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">IDisposable接口</span></li></ol><p id=\"ud91b6d60\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在C#中，推荐使用System.IDisposable接口替代析构函数。IDisposable接口定义了一种模式，该模式为释放非托管的资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。IDisposable接口声明了一个Dispose()方法，它不带参数，返回void。例如：</span></p><pre data-language=\"csharp\" id=\"zNRGL\" class=\"ne-codeblock language-csharp\"><code>public class People : IDisposable\n{\n        public void Dispose()\n        {\n            this.Dispose();\n        }\n}</code></pre><p id=\"u9346403f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Dispose()方法的实现代码显式地释放由对象直接使用的所有非托管资源，并在所有也实现了IDisposable接口的封装对象上调用Dispose()方法。这样，Dispose()方法为何时释放非托管资源提供了精确的控制。</span></p><ol start=\"3\" class=\"ne-ol\"><li id=\"ua7e72672\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">using语句</span></li></ol><p id=\"u01ee074f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">C#提供了一种语法，可以确保在实现了IDisposable接口的对象的引用超出作用域时，在该对象上自动调用Dispose()方法。该语法使用了using关键字来完成此工作。例如：</span></p><pre data-language=\"csharp\" id=\"dIpOs\" class=\"ne-codeblock language-csharp\"><code>using (var people = new People())\n{\n      // 要处理的代码\n}</code></pre><ol start=\"4\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"ubc62b514\" data-lake-index-type=\"1\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">析构函数和Dispose()的区别</span></li></ol><ol class=\"ne-ol\"><li id=\"u6db88e52\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">析构函数</span></li></ol><p id=\"u21d9619f\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">析构函数  主要是用来释放非托管资源，等着GC的时候去把非托管资源释放掉，系统自动执行。GC回收的时候，CLR一定调用的，但是可能有延迟(释放对象不知道要多久呢)。</span></p><ol start=\"2\" class=\"ne-ol\"><li id=\"u2c003e29\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Dispose()</span></li></ol><p id=\"u4e4fb3de\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">Dispose() 也是释放非托管资源的，主动释放，方法本身是没有意义的，我们需要在方法里面实现对资源的释放。GC的时候不会调用Dispose()方法，而是使用对象时，使用者主动调用这个方法，去释放非托管资源。</span></p><ol start=\"5\" data-index-type=\"1\" class=\"ne-ol\"><li id=\"u97f58afe\" data-lake-index-type=\"1\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">终结器和IDisposable接口的规则</span></li></ol><ol class=\"ne-ol\"><li id=\"u054a077a\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">如果类定义了实现IDisposable的成员（类里面的属性实现了IDisposable接口），那么该类也应该实现IDisposable接口。</span></li><li id=\"u24447409\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">实现IDisposable并不意味着也应该实现一个终结器。终结器会带来额外的开销，因为它需要创建一个对象，释放该对象的内存，需要GC的额外处理。只在需要时才应该实现终结器，例如。发布本机资源。要释放本机资源，就需要终结器。</span></li><li id=\"uab16bc2b\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">如果实现了终结器，也应该实现IDisposable接口。这样，本机资源可以早些释放，而不仅是在GC找出被占用的资源时，才释放资源。</span></li><li id=\"u3f2f8159\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">在终结器的实现代码中，不能访问已经终结的对象。终结器的执行顺序是没有保证的。</span></li><li id=\"u8f2a420a\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">如果所使用的一个对象实现了IDisposable接口，就在不再需要对象时调用Dispose方法。如果在方法中使用这个对象，using语句比较方便。如果对象是类的一个成员，那么类也应该实现IDisposable接口。</span></li></ol></div>"
}