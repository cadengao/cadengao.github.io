{
  "uuid": "54197715.119619453",
  "id": 119619453,
  "title": "WPF-依赖属性【Area】",
  "cover": "https://cdn.nlark.com/yuque/0/2023/png/123299/1679911789038-3a03f639-2f0c-4772-b11f-1e563db33701.png",
  "book_id": 54197715,
  "book_name": "Area",
  "public": 0,
  "word_count": 1102,
  "created_at": "2023-03-27T09:50:09",
  "updated_at": "2024-10-20T09:59:20",
  "body_html": "<!doctype html><div class=\"lake-content\" typography=\"classic\"><h1 id=\"yEMoH\"><span class=\"ne-text\">依赖属性介绍</span></h1><p id=\"ub4748045\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">WPF提供了一组服务，这些服务可用于扩展公共语言运行时 (CLR) 属性的功能。 这些服务通常统称为 WPF 属性系统。 由 WPF 属性系统支持的属性称为依赖属性。</span></p><p id=\"uf17f2542\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119619453/image/0.png\" width=\"954\" id=\"udf59b6c3\" class=\"ne-image\"></p><h1 id=\"m6kqx\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">为什么要使用依赖属性</span></h1><ul class=\"ne-ul\"><li id=\"uf93516d0\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">场景一：一个界面有100个按钮，每个按钮有100个属性，那么系统需要为10000个属性分配内存，然而大部分属性都是使用初始时的默认值。</span></li><li id=\"u8a779f9f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">场景二：假如按钮父类Background为黑色，按钮样式的Background为红色，按钮的Background属性绑定到了另外一个按钮的背景色（蓝色），同时这个按钮正在播放一个动画，Background由黄色变成绿色，那么按钮显示出来的背景色到底是什么颜色，动画播放完后又会是什么颜色？</span></li></ul><h1 id=\"BJnSc\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">依赖属性使用的场景</span></h1><ol class=\"ne-ol\"><li id=\"u059c5917\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">希望可在样式中设置属性</span></li><li id=\"u9fcf4cf7\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">希望属性支持数据绑定</span></li><li id=\"u82eef995\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">希望可使用动态资源引用设置属性</span></li><li id=\"u616ef079\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">希望从元素树中的父元素自动继承属性值</span></li><li id=\"u07e2febc\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">希望属性可进行动画处理</span></li><li id=\"ub49e2a50\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">希望属性在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告</span></li><li id=\"u63014628\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(51, 51, 51); font-size: 14px\">希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象</span></li></ol><h1 id=\"aeWXC\"><span class=\"ne-text\">代码示例</span></h1><pre data-language=\"csharp\" id=\"aDiMr\" class=\"ne-codeblock language-csharp\"><code>class Person : DependencyObject//继承DependencyObject类\n{\n    //注册依赖属性\n    public static readonly DependencyProperty CountryProperty = DependencyProperty.Register(&quot;Country&quot;, typeof(string), typeof(Person), new PropertyMetadata(&quot;中国&quot;, OnValueChanged), new ValidateValueCallback(CountryValidateValueCallback));\n\t\n    //Country是一个依赖属性\n    public string Country\n    {\n        //属性包装器\n        get { return (string)GetValue(CountryProperty); }\n        set { SetValue(CountryProperty, value); }\n    }\n    \n    //Name是一个普通CLR属性\n    public string Name { get; set; }\n    \n    //当只发生改变时回调的方法\n    private static void OnValueChanged(DependencyObject dpobj, DependencyPropertyChangedEventArgs e)\n    {\n    }\n   \n    //属性值验证\n    public static bool CountryValidateValueCallback(object value)\n    {\n        string sCountry = (string)value;\n        if (sCountry.Equals(&quot;美国&quot;))\n        {\n            return false;\n        }\n        return true;\n    }\n}</code></pre><p id=\"u45f2cceb\" class=\"ne-p\"><span class=\"ne-text\">普通CLR属性的值存放于字段中，而依赖属性的值存放于</span><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">DependencyProperty对应的属性值</span></p><h1 id=\"DR2KP\"><span class=\"ne-text\" style=\"color: rgb(0, 0, 0)\">依赖属性原型</span></h1><h2 id=\"RqC3x\"><span class=\"ne-text\">全局RegisteredDps需要</span><span class=\"ne-text\" style=\"color: rgb(51, 51, 51)\">传入的名字和注册类的的HashCode取异或来生成Key，以此来获取默认值</span></h2><pre data-language=\"csharp\" id=\"BYCzl\" class=\"ne-codeblock language-csharp\"><code>public class DependencyProperty\n{\n    private static int globalIndex = 0;\n    internal static Dictionary&lt;object, DependencyProperty&gt; RegisteredDps = new Dictionary&lt;object, DependencyProperty&gt;();\n    internal string Name;\n    internal object Value;\n    internal int Index;\n    internal object HashCode;\n    private List&lt;PropertyMetadata&gt; _metadataMap = new List&lt;PropertyMetadata&gt;();\n    private PropertyMetadata _defaultMetadata;\n \n    private DependencyProperty(string name, Type propertyName, Type ownerType, object defaultValue)\n    {\n        this.Name = name;\n        this.Value = defaultValue;\n        this.HashCode = name.GetHashCode() ^ ownerType.GetHashCode();\n \n        PropertyMetadata metadata = new PropertyMetadata(defaultValue) { Type = ownerType };\n        _metadataMap.Add(metadata);\n        _defaultMetadata = metadata;\n    }\n \n    public static DependencyProperty Register(string name, Type propertyType, Type ownerType, object defaultValue)\n    {\n        DependencyProperty dp = new DependencyProperty(name, propertyType, ownerType, defaultValue);\n        globalIndex++;\n        dp.Index = globalIndex;\n        RegisteredDps.Add(dp.HashCode, dp);\n        return dp;\n    }\n \n    public void OverrideMetadata(Type forType, PropertyMetadata metadata)\n    {\n        metadata.Type = forType;\n        _metadataMap.Add(metadata);\n    }\n \n    public PropertyMetadata GetMetadata(Type type)\n    {\n        PropertyMetadata medatata = _metadataMap.FirstOrDefault((i) =&gt; i.Type == type) ??\n            _metadataMap.FirstOrDefault((i) =&gt; type.IsSubclassOf(i.Type));\n        if (medatata == null)\n        {\n            medatata = _defaultMetadata;\n        }\n        return medatata;\n    }\n}</code></pre><h2 id=\"uzK6N\"><span class=\"ne-text\">非默认值通过PropertyIndex从_effectiveValues来获取</span></h2><pre data-language=\"csharp\" id=\"ro9rq\" class=\"ne-codeblock language-csharp\"><code>public class DependencyObject\n{\n   private List&lt;EffectiveValueEntry&gt; _effectiveValues = new List&lt;EffectiveValueEntry&gt;();\n \n   public object GetValue(DependencyProperty dp)\n   {\n       EffectiveValueEntry effectiveValue = _effectiveValues.FirstOrDefault((i) =&gt; i.PropertyIndex == dp.Index);\n       if (effectiveValue.PropertyIndex != 0)\n       {\n           return effectiveValue.Value;\n       }\n       else\n       {\n           PropertyMetadata metadata;\n           metadata = DependencyProperty.RegisteredDps[dp.HashCode].GetMetadata(this.GetType());\n           return metadata.Value;\n       }\n   }\n}</code></pre><h2 id=\"jW03l\"><span class=\"ne-text\">依赖属性继承类的默认值可更改</span></h2><pre data-language=\"csharp\" id=\"OybRL\" class=\"ne-codeblock language-csharp\"><code>public class SubDependencyObject : DependencyObject\n{\n    static SubDependencyObject()\n    {\n        NameProperty.OverrideMetadata(typeof(SubDependencyObject), new PropertyMetadata(&quot;SubName&quot;));\n    }\n}</code></pre><h2 id=\"UiZhs\"><span class=\"ne-text\">多属性值</span></h2><pre data-language=\"csharp\" id=\"jEQbg\" class=\"ne-codeblock language-csharp\"><code>internal struct EffectiveValueEntry\n{\n    private object _value;\n \n    internal int PropertyIndex { get; set; }\n \n    internal object Value \n    {\n        get\n        {\n            return _value;\n        }\n        set\n        {\n            _value = value;\n        }\n    }\n \n    internal ModifiedValue ModifiedValue \n    {\n        get\n        {\n            if (this._value != null)\n            {\n                return (this._value as ModifiedValue);\n            }\n            return null;\n        }\n    }\n}\n\ninternal class ModifiedValue\n{\n    internal object AnimatedValue { get; set; }\n    internal object BaseValue { get; set; }\n    internal object CoercedValue { get; set; }\n    internal object ExpressionValue { get; set; }\n}</code></pre><pre data-language=\"xml\" id=\"QBCz3\" class=\"ne-codeblock language-xml\"><code>&lt;Window x:Class=&quot;WpfDependencyProperties.MainWindow&quot;\n  xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;\n  xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;\n  xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;\n  xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;\n  xmlns:local=&quot;clr-namespace:WpfDependencyProperties&quot;\n  mc:Ignorable=&quot;d&quot;\n  Title=&quot;MainWindow&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt;\n  &lt;Grid&gt;\n    &lt;Button x:Name=&quot;myButton&quot; Width=&quot;100&quot; Height=&quot;30&quot; Content=&quot;点击&quot;&gt;\n      &lt;Button.Style&gt;\n        &lt;Style TargetType=&quot;{x:Type Button}&quot;&gt;\n          &lt;Setter Property=&quot;Background&quot; Value=&quot;Yellow&quot;/&gt;\n          &lt;Style.Triggers&gt;\n            &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;\n              &lt;Setter Property=&quot;Background&quot; Value=&quot;Red&quot; /&gt;\n            &lt;/Trigger&gt;\n          &lt;/Style.Triggers&gt;\n        &lt;/Style&gt;\n      &lt;/Button.Style&gt;\n    &lt;/Button&gt;\n  &lt;/Grid&gt;\n&lt;/Window&gt;</code></pre><p id=\"u4f9546a5\" class=\"ne-p\"><img src=\"https://file.cadengao.com/assets/doc/54197715.119619453/image/1.png\" width=\"498\" id=\"u9f0b8d09\" class=\"ne-image\"></p><h1 id=\"exgLo\"><span class=\"ne-text\">附加属性</span></h1><pre data-language=\"csharp\" id=\"enGgW\" class=\"ne-codeblock language-csharp\"><code>public class School : DependencyObject\n{\n    public static int GetGrade(DependencyObject obj)\n    {\n        return (int)obj.GetValue(GradeProperty);\n    }\n    public static void SetGrade(DependencyObject obj, int value)\n    {\n        obj.SetValue(GradeProperty, value);\n    }\n    public static readonly DependencyProperty GradeProperty =\n        DependencyProperty.RegisterAttached(&quot;Grade&quot;, typeof(int), typeof(School), new UIPropertyMetadata(0));\n}</code></pre><p id=\"u46147f4e\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\">可以看到，附加属性已依赖属性有两点不同：</span></p><ol class=\"ne-ol\"><li id=\"u6763df86\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\">附加属性使用的RegisterAttached方法，而依赖属性使用的是Register方法</span></li><li id=\"ue8bb2feb\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\">附加属性使用两个方法进行包装，依赖属性使用CLR属性对GetValue和SetValue两个方法进行包装</span></li></ol><p id=\"uf1ec23d8\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\"></span></p><p id=\"u596000ac\" class=\"ne-p\"><span class=\"ne-text\" style=\"color: rgb(77, 77, 77); font-size: 16px\"></span></p><div id=\"m7dRo\" class=\"ne-bookmark\"><a href=\"https://www.cnblogs.com/ghhjanes/p/11261011.html\" target=\"_blank\">https://www.cnblogs.com/ghhjanes/p/11261011.html</a></div><div id=\"yOBle\" class=\"ne-bookmark\"><a href=\"https://www.cnblogs.com/Zhouyongh/archive/2009/09/10/1564099.html\" target=\"_blank\">https://www.cnblogs.com/Zhouyongh/archive/2009/09/10/1564099.html</a></div><div id=\"y77o0\" class=\"ne-bookmark\"><a href=\"https://www.cnblogs.com/zhili/p/WPFDependencyProperty.html\" target=\"_blank\">https://www.cnblogs.com/zhili/p/WPFDependencyProperty.html</a></div></div>"
}